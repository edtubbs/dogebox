--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/Kconfig
@@ -0,0 +1,87 @@
+config FIQ_DEBUGGER
+	tristate "FIQ Mode Serial Debugger"
+	default n
+	depends on ARM || ARM64
+	help
+	  The FIQ serial debugger can accept commands even when the
+	  kernel is unresponsive due to being stuck with interrupts
+	  disabled.
+
+config FIQ_DEBUGGER_NO_SLEEP
+	bool "Keep serial debugger active"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  Enables the serial debugger at boot. Passing
+	  fiq_debugger.no_sleep on the kernel commandline will
+	  override this config option.
+
+config FIQ_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON
+	bool "Don't disable wakeup IRQ when debugger is active"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  Don't disable the wakeup irq when enabling the uart clock.  This will
+	  cause extra interrupts, but it makes the serial debugger usable with
+	  on some MSM radio builds that ignore the uart clock request in power
+	  collapse.
+
+config FIQ_DEBUGGER_CONSOLE
+	bool "Console on FIQ Serial Debugger port"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  Enables a console so that printk messages are displayed on
+	  the debugger serial port as the occur.
+
+config FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE
+	bool "Put the FIQ debugger into console mode by default"
+	depends on FIQ_DEBUGGER_CONSOLE
+	default n
+	help
+	  If enabled, this puts the fiq debugger into console mode by default.
+	  Otherwise, the fiq debugger will start out in debug mode.
+
+config FIQ_DEBUGGER_TRUST_ZONE
+	bool "Uart FIQ is captured by trust zone, then passed to non-secure world"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  It is for ARM v7/V8 arch.
+
+config FIQ_DEBUGGER_UART_OVERLAY
+	bool "Install uart DT overlay"
+	depends on FIQ_DEBUGGER
+	select OF_OVERLAY
+	default n
+	help
+	  If enabled, fiq debugger is calling fiq_debugger_uart_overlay()
+	  that will apply overlay uart_overlay@0 to disable proper uart.
+
+config FIQ_WATCHDOG
+	bool
+	select FIQ_DEBUGGER
+	select PSTORE_RAM
+	default n
+
+config RK_CONSOLE_THREAD
+	bool "Console write by thread"
+	depends on FIQ_DEBUGGER
+	default n
+	help
+	  Normal kernel printk will write out to UART by "kconsole" kthread
+
+config FIQ_DEBUGGER_FIQ_GLUE
+	bool "Uart FIQ is captured by linux"
+	depends on FIQ_DEBUGGER && ARM
+	select FIQ_GLUE
+	default n
+	help
+	  It is for ARM v7 arch without trust zone.
+
+config ROCKCHIP_FIQ_DEBUGGER
+	tristate "Rockchip FIQ Debugger"
+	depends on FIQ_DEBUGGER
+	default FIQ_DEBUGGER
+	help
+	  Say y here to enable Rockchip FIQ Debugger platform driver.

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_FIQ_DEBUGGER)	+= fiq_debugger.o
+obj-$(CONFIG_FIQ_WATCHDOG)	+= fiq_watchdog.o
+obj-$(CONFIG_ROCKCHIP_FIQ_DEBUGGER) += rk_fiq_debugger.o

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/fiq_debugger.c
@@ -0,0 +1,1729 @@
+/*
+ * drivers/staging/android/fiq_debugger.c
+ *
+ * Serial Debugger Interface accessed through an FIQ interrupt.
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/stdarg.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/console.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/kernel_stat.h>
+#include <linux/kmsg_dump.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+#include <linux/sched/signal.h>
+#include <linux/slab.h>
+#include <linux/smp.h>
+#include <linux/timer.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/ptrace.h>
+#include <linux/proc_fs.h>
+
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+#include <linux/rockchip/rockchip_sip.h>
+#include "rk_fiq_debugger.h"
+#endif
+
+#ifdef CONFIG_FIQ_GLUE
+#include <asm/fiq_glue.h>
+#endif
+
+#ifdef CONFIG_FIQ_DEBUGGER_UART_OVERLAY
+#include <linux/of.h>
+#endif
+
+#include <linux/uaccess.h>
+#include <linux/cpuhotplug.h>
+
+#include "fiq_debugger.h"
+#include "fiq_debugger_priv.h"
+#include "fiq_debugger_ringbuf.h"
+
+#ifdef CONFIG_ROCKCHIP_DEBUG
+#include "../rockchip_debug.h"
+#endif
+
+#define DEBUG_MAX 64
+#define CMD_COUNT 0x0f
+#define MAX_UNHANDLED_FIQ_COUNT 1000000
+
+#ifdef CONFIG_ARCH_ROCKCHIP
+#define MAX_FIQ_DEBUGGER_PORTS 1
+#else
+#define MAX_FIQ_DEBUGGER_PORTS 4
+#endif
+
+struct fiq_debugger_state {
+#ifdef CONFIG_FIQ_GLUE
+	struct fiq_glue_handler handler;
+#endif
+	struct fiq_debugger_output output;
+
+	int fiq;
+	int uart_irq;
+	int signal_irq;
+	int wakeup_irq;
+	bool wakeup_irq_no_set_wake;
+	struct clk *clk;
+	struct fiq_debugger_pdata *pdata;
+	struct platform_device *pdev;
+
+	char debug_cmd[DEBUG_MAX];
+	int debug_busy;
+	int debug_abort;
+
+	char debug_buf[DEBUG_MAX];
+	int debug_count;
+
+#ifdef CONFIG_ARCH_ROCKCHIP
+	char cmd_buf[CMD_COUNT + 1][DEBUG_MAX];
+	int back_pointer;
+	int current_pointer;
+#endif
+
+	bool no_sleep;
+	bool debug_enable;
+	bool ignore_next_wakeup_irq;
+	struct timer_list sleep_timer;
+	spinlock_t sleep_timer_lock;
+	bool uart_enabled;
+	struct wakeup_source debugger_wake_src;
+	bool console_enable;
+	int current_cpu;
+	atomic_t unhandled_fiq_count;
+	bool in_fiq;
+
+	struct work_struct work;
+	spinlock_t work_lock;
+	char work_cmd[DEBUG_MAX];
+
+#ifdef CONFIG_FIQ_DEBUGGER_CONSOLE
+	spinlock_t console_lock;
+	struct console console;
+	struct tty_port tty_port;
+	struct fiq_debugger_ringbuf *tty_rbuf;
+	bool syslog_dumping;
+#endif
+
+#ifdef CONFIG_ARCH_ROCKCHIP
+	unsigned int last_irqs[1024];
+	unsigned int last_local_irqs[NR_CPUS][32];
+#else
+	unsigned int last_irqs[NR_IRQS];
+	unsigned int last_local_timer_irqs[NR_CPUS];
+#endif
+};
+
+#ifdef CONFIG_FIQ_DEBUGGER_CONSOLE
+static struct tty_driver *fiq_tty_driver;
+#endif
+
+#ifdef CONFIG_FIQ_DEBUGGER_NO_SLEEP
+static bool initial_no_sleep = true;
+#else
+static bool initial_no_sleep;
+#endif
+
+#ifdef CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE
+static bool initial_debug_enable = true;
+static bool initial_console_enable = true;
+#else
+static bool initial_debug_enable;
+static bool initial_console_enable;
+#endif
+
+static struct fiq_debugger_state *g_state;
+static bool fiq_kgdb_enable;
+static bool fiq_debugger_disable;
+
+module_param_named(no_sleep, initial_no_sleep, bool, 0644);
+module_param_named(debug_enable, initial_debug_enable, bool, 0644);
+module_param_named(console_enable, initial_console_enable, bool, 0644);
+module_param_named(kgdb_enable, fiq_kgdb_enable, bool, 0644);
+module_param_named(disable, fiq_debugger_disable, bool, 0644);
+
+#ifdef CONFIG_ARM64
+#include "fiq_debugger_arm64.c"
+#else
+#include "fiq_debugger_arm.c"
+#endif
+
+#ifdef CONFIG_FIQ_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON
+static inline
+void fiq_debugger_enable_wakeup_irq(struct fiq_debugger_state *state) {}
+static inline
+void fiq_debugger_disable_wakeup_irq(struct fiq_debugger_state *state) {}
+#else
+static inline
+void fiq_debugger_enable_wakeup_irq(struct fiq_debugger_state *state)
+{
+	if (state->wakeup_irq < 0)
+		return;
+	enable_irq(state->wakeup_irq);
+	if (!state->wakeup_irq_no_set_wake)
+		enable_irq_wake(state->wakeup_irq);
+}
+static inline
+void fiq_debugger_disable_wakeup_irq(struct fiq_debugger_state *state)
+{
+	if (state->wakeup_irq < 0)
+		return;
+	disable_irq_nosync(state->wakeup_irq);
+	if (!state->wakeup_irq_no_set_wake)
+		disable_irq_wake(state->wakeup_irq);
+}
+#endif
+
+static inline bool fiq_debugger_have_fiq(struct fiq_debugger_state *state)
+{
+	return (state->fiq >= 0);
+}
+
+static void fiq_debugger_force_irq(struct fiq_debugger_state *state)
+{
+	unsigned int irq = state->signal_irq;
+
+	if (irq < 0)
+		return;
+
+	if (state->pdata->force_irq) {
+		state->pdata->force_irq(state->pdev, irq);
+	} else {
+		struct irq_chip *chip = irq_get_chip(irq);
+
+		if (chip && chip->irq_retrigger)
+			chip->irq_retrigger(irq_get_irq_data(irq));
+	}
+}
+
+static void fiq_debugger_uart_enable(struct fiq_debugger_state *state)
+{
+	if (state->clk)
+		clk_enable(state->clk);
+	if (state->pdata->uart_enable)
+		state->pdata->uart_enable(state->pdev);
+}
+
+static void fiq_debugger_uart_disable(struct fiq_debugger_state *state)
+{
+	if (state->pdata->uart_disable)
+		state->pdata->uart_disable(state->pdev);
+	if (state->clk)
+		clk_disable(state->clk);
+}
+
+static void fiq_debugger_uart_flush(struct fiq_debugger_state *state)
+{
+	if (state->pdata->uart_flush)
+		state->pdata->uart_flush(state->pdev);
+}
+
+static void fiq_debugger_putc(struct fiq_debugger_state *state, char c)
+{
+	if (state->pdata->uart_putc)
+		state->pdata->uart_putc(state->pdev, c);
+}
+
+static void fiq_debugger_puts(struct fiq_debugger_state *state, char *s)
+{
+	unsigned c;
+	while ((c = *s++)) {
+		if (c == '\n')
+			fiq_debugger_putc(state, '\r');
+		fiq_debugger_putc(state, c);
+	}
+}
+
+static void fiq_debugger_prompt(struct fiq_debugger_state *state)
+{
+	fiq_debugger_puts(state, "debug> ");
+}
+
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+static void fiq_debugger_dump_kernel_log(struct fiq_debugger_state *state)
+{
+	char buf[512];
+	size_t len;
+	struct kmsg_dump_iter iter;
+
+	kmsg_dump_rewind(&iter);
+	while (kmsg_dump_get_line(&iter, true, buf,
+					 sizeof(buf) - 1, &len)) {
+		buf[len] = 0;
+		fiq_debugger_puts(state, buf);
+	}
+}
+#endif
+
+__printf(2, 3)
+static void fiq_debugger_printf(struct fiq_debugger_output *output,
+			       const char *fmt, ...)
+{
+	struct fiq_debugger_state *state;
+	char buf[256];
+	va_list ap;
+
+	state = container_of(output, struct fiq_debugger_state, output);
+	va_start(ap, fmt);
+	vsnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+
+	fiq_debugger_puts(state, buf);
+}
+
+/* Safe outside fiq context */
+__printf(2, 3)
+static int fiq_debugger_printf_nfiq(void *cookie, const char *fmt, ...)
+{
+	struct fiq_debugger_state *state = cookie;
+	char buf[256];
+	va_list ap;
+	unsigned long irq_flags;
+
+	va_start(ap, fmt);
+	vsnprintf(buf, 128, fmt, ap);
+	va_end(ap);
+
+	local_irq_save(irq_flags);
+	fiq_debugger_puts(state, buf);
+	fiq_debugger_uart_flush(state);
+	local_irq_restore(irq_flags);
+	return state->debug_abort;
+}
+
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+static void fiq_debugger_dump_irqs(struct fiq_debugger_state *state)
+{
+	int n;
+	struct irq_desc *desc;
+
+	fiq_debugger_printf(&state->output,
+			"irqnr       total  since-last   status  name\n");
+	for_each_irq_desc(n, desc) {
+		struct irqaction *act = desc->action;
+		if (!act && !kstat_irqs_usr(n))
+			continue;
+		fiq_debugger_printf(&state->output, "%5d: %10u %11u %8x  %s\n", n,
+			kstat_irqs_usr(n),
+			kstat_irqs_usr(n) - state->last_irqs[n],
+			desc->status_use_accessors,
+			(act && act->name) ? act->name : "???");
+		state->last_irqs[n] = kstat_irqs_usr(n);
+	}
+}
+#endif
+
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+static void fiq_debugger_do_ps(struct fiq_debugger_state *state)
+{
+	struct task_struct *g;
+	struct task_struct *p;
+	unsigned task_state;
+	static const char stat_nam[] = "RSDTtZX";
+
+	fiq_debugger_printf(&state->output, "pid   ppid  prio task            pc\n");
+	read_lock(&tasklist_lock);
+	do_each_thread(g, p) {
+		task_state = p->__state ? __ffs(p->__state) + 1 : 0;
+		fiq_debugger_printf(&state->output,
+			     "%5d %5d %4d ", p->pid, p->parent->pid, p->prio);
+		fiq_debugger_printf(&state->output, "%-13.13s %c", p->comm,
+			     task_state >= sizeof(stat_nam) ? '?' : stat_nam[task_state]);
+		if (task_state == TASK_RUNNING)
+			fiq_debugger_printf(&state->output, " running\n");
+		else
+			fiq_debugger_printf(&state->output, " %08lx\n",
+					thread_saved_pc(p));
+	} while_each_thread(g, p);
+	read_unlock(&tasklist_lock);
+}
+#endif
+
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+#ifdef CONFIG_FIQ_DEBUGGER_CONSOLE
+static void fiq_debugger_begin_syslog_dump(struct fiq_debugger_state *state)
+{
+	state->syslog_dumping = true;
+}
+
+static void fiq_debugger_end_syslog_dump(struct fiq_debugger_state *state)
+{
+	state->syslog_dumping = false;
+}
+#else
+extern int do_syslog(int type, char __user *bug, int count);
+static void fiq_debugger_begin_syslog_dump(struct fiq_debugger_state *state)
+{
+	do_syslog(5 /* clear */, NULL, 0);
+}
+
+static void fiq_debugger_end_syslog_dump(struct fiq_debugger_state *state)
+{
+	fiq_debugger_dump_kernel_log(state);
+}
+#endif
+#endif
+
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+static void fiq_debugger_do_sysrq(struct fiq_debugger_state *state, char rq)
+{
+	if ((rq == 'g' || rq == 'G') && !fiq_kgdb_enable) {
+		fiq_debugger_printf(&state->output, "sysrq-g blocked\n");
+		return;
+	}
+	fiq_debugger_begin_syslog_dump(state);
+	__handle_sysrq(rq, false);
+	fiq_debugger_end_syslog_dump(state);
+}
+#endif
+
+#ifdef CONFIG_KGDB
+static void fiq_debugger_do_kgdb(struct fiq_debugger_state *state)
+{
+	if (!fiq_kgdb_enable) {
+		fiq_debugger_printf(&state->output, "kgdb through fiq debugger not enabled\n");
+		return;
+	}
+
+	fiq_debugger_printf(&state->output, "enabling console and triggering kgdb\n");
+	state->console_enable = true;
+	handle_sysrq('g');
+}
+#endif
+
+static void fiq_debugger_schedule_work(struct fiq_debugger_state *state,
+		char *cmd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&state->work_lock, flags);
+	if (state->work_cmd[0] != '\0') {
+		fiq_debugger_printf(&state->output, "work command processor busy\n");
+		spin_unlock_irqrestore(&state->work_lock, flags);
+		return;
+	}
+
+	strlcpy(state->work_cmd, cmd, sizeof(state->work_cmd));
+	spin_unlock_irqrestore(&state->work_lock, flags);
+
+	schedule_work(&state->work);
+}
+
+static void fiq_debugger_work(struct work_struct *work)
+{
+	struct fiq_debugger_state *state;
+	char work_cmd[DEBUG_MAX];
+	char *cmd;
+	unsigned long flags;
+
+	state = container_of(work, struct fiq_debugger_state, work);
+
+	spin_lock_irqsave(&state->work_lock, flags);
+
+	strlcpy(work_cmd, state->work_cmd, sizeof(work_cmd));
+	state->work_cmd[0] = '\0';
+
+	spin_unlock_irqrestore(&state->work_lock, flags);
+
+	cmd = work_cmd;
+	if (!strncmp(cmd, "reboot", 6)) {
+		cmd += 6;
+		while (*cmd == ' ')
+			cmd++;
+		if (*cmd != '\0')
+			kernel_restart(cmd);
+		else
+			kernel_restart(NULL);
+	} else {
+		fiq_debugger_printf(&state->output, "unknown work command '%s'\n",
+				work_cmd);
+	}
+}
+
+/* This function CANNOT be called in FIQ context */
+static void fiq_debugger_irq_exec(struct fiq_debugger_state *state, char *cmd)
+{
+	int invalid_cmd = 0;
+
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+	if (!strcmp(cmd, "ps"))
+		fiq_debugger_do_ps(state);
+	if (!strcmp(cmd, "sysrq"))
+		fiq_debugger_do_sysrq(state, 'h');
+	if (!strncmp(cmd, "sysrq ", 6))
+		fiq_debugger_do_sysrq(state, cmd[6]);
+#endif
+#ifdef CONFIG_KGDB
+	if (!strcmp(cmd, "kgdb"))
+		fiq_debugger_do_kgdb(state);
+#endif
+	if (!strncmp(cmd, "reboot", 6))
+		fiq_debugger_schedule_work(state, cmd);
+#ifdef CONFIG_ARCH_ROCKCHIP
+	else {
+		invalid_cmd = 1;
+		memset(state->debug_buf, 0, DEBUG_MAX);
+	}
+
+	if (invalid_cmd == 0) {
+		state->current_pointer =
+				(state->current_pointer - 1) & CMD_COUNT;
+		if (strcmp(state->cmd_buf[state->current_pointer], state->debug_buf)) {
+			state->current_pointer =
+				(state->current_pointer + 1) & CMD_COUNT;
+			memset(state->cmd_buf[state->current_pointer], 0, DEBUG_MAX);
+			strcpy(state->cmd_buf[state->current_pointer], state->debug_buf);
+		}
+		memset(state->debug_buf, 0, DEBUG_MAX);
+		state->current_pointer = (state->current_pointer + 1) & CMD_COUNT;
+		state->back_pointer = state->current_pointer;
+	}
+#endif
+}
+
+#ifdef CONFIG_ARCH_ROCKCHIP
+static char cmd_buf[][16] = {
+		{"pc"},
+		{"regs"},
+		{"allregs"},
+		{"bt"},
+		{"reboot"},
+#ifdef CONFIG_ROCKCHIP_DEBUG
+		{"pcsr"},
+#endif
+		{"sleep"},
+		{"nosleep"},
+		{"console"},
+		{"cpu"},
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+		{"reset"},
+		{"irqs"},
+		{"kmsg"},
+		{"version"},
+		{"ps"},
+		{"sysrq"},
+#endif
+
+#ifdef CONFIG_KGDB
+		{"kgdb"},
+#endif
+};
+#endif
+
+static void fiq_debugger_help(struct fiq_debugger_state *state)
+{
+	fiq_debugger_printf(&state->output,
+				"FIQ Debugger commands:\n"
+				" pc            PC status\n"
+				" regs          Register dump\n"
+				" allregs       Extended Register dump\n"
+				" bt            Stack trace\n"
+#ifdef CONFIG_ROCKCHIP_DEBUG
+				" pcsr          Dump all cpus pc by DBGPCSR\n"
+#endif
+				" cpu           Current CPU\n"
+				" cpu <number>  Switch to CPU<number>\n"
+				" reboot [<c>]  Reboot with command <c>\n");
+
+	fiq_debugger_printf(&state->output,
+				" sleep         Allow sleep while in FIQ\n"
+				" nosleep       Disable sleep while in FIQ\n"
+				" console       Switch terminal to console\n");
+
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+	fiq_debugger_printf(&state->output,
+				" reset [<c>]   Hard reset with command <c>\n"
+				" irqs          Interrupt status\n"
+				" kmsg          Kernel log\n"
+				" version       Kernel version\n");
+
+	fiq_debugger_printf(&state->output,
+				" ps            Process list\n"
+				" sysrq         sysrq options\n"
+				" sysrq <param> Execute sysrq with <param>\n");
+#endif
+
+#ifdef CONFIG_KGDB
+	fiq_debugger_printf(&state->output,
+				" kgdb          Enter kernel debugger\n");
+#endif
+}
+
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+static void fiq_debugger_take_affinity(struct fiq_debugger_state *state, int cpu)
+{
+	struct cpumask cpumask;
+
+	cpumask_clear(&cpumask);
+	cpumask_set_cpu(cpu, &cpumask);
+	irq_set_affinity(state->uart_irq, &cpumask);
+}
+#else
+static void fiq_debugger_take_affinity(struct fiq_debugger_state *state, int cpu)
+{
+}
+#endif
+
+static void fiq_debugger_switch_cpu(struct fiq_debugger_state *state, int cpu)
+{
+	if (!cpu_online(cpu)) {
+		fiq_debugger_printf(&state->output, "cpu %d offline\n", cpu);
+		return;
+	}
+
+	if (!fiq_debugger_have_fiq(state)) {
+		fiq_debugger_take_affinity(state, cpu);
+	}
+#ifdef CONFIG_ARCH_ROCKCHIP
+	else {
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+		if (sip_fiq_debugger_is_enabled() ||
+		    sdei_fiq_debugger_is_enabled()) {
+			if (state->pdata->switch_cpu) {
+				state->pdata->switch_cpu(state->pdev, cpu);
+				state->current_cpu = cpu;
+			}
+			return;
+		}
+#else
+		struct cpumask cpumask;
+
+		cpumask_clear(&cpumask);
+		cpumask_set_cpu(cpu, &cpumask);
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+		irq_set_affinity(state->fiq, &cpumask);
+		irq_set_affinity(state->uart_irq, &cpumask);
+#endif
+#endif
+	}
+#endif
+	state->current_cpu = cpu;
+}
+
+static bool fiq_debugger_fiq_exec(struct fiq_debugger_state *state,
+			const char *cmd, const struct pt_regs *regs,
+			void *svc_sp)
+{
+	bool signal_helper = false;
+
+	if (!strcmp(cmd, "help") || !strcmp(cmd, "?")) {
+		fiq_debugger_help(state);
+	} else if (!strcmp(cmd, "pc")) {
+		fiq_debugger_dump_pc(&state->output, regs);
+	} else if (!strcmp(cmd, "regs")) {
+		fiq_debugger_dump_regs(&state->output, regs);
+	} else if (!strcmp(cmd, "allregs")) {
+		fiq_debugger_dump_allregs(&state->output, regs);
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+	} else if (!strcmp(cmd, "bt")) {
+		/*
+		 * ARM64:
+		 * Cpu is at ELx(1 or 2), but EL0_SP(svc_sp) may be user space.
+		 * If EL0_SP.63 is 0, use TTBR0.
+		 */
+		if (user_mode((struct pt_regs *)regs) ||
+		    (IS_ENABLED(CONFIG_ARM64) && (((unsigned long)svc_sp & 0x8000000000000000) == 0)) ||
+		    (IS_ENABLED(CONFIG_ARM) && (((unsigned long)svc_sp < PAGE_OFFSET) || ((unsigned long)svc_sp > -256UL))))
+			fiq_debugger_printf(&state->output, "User mode\n");
+		else
+			fiq_debugger_dump_stacktrace(&state->output, regs,
+						     100, svc_sp);
+	} else if (!strncmp(cmd, "reset", 5)) {
+		cmd += 5;
+		while (*cmd == ' ')
+			cmd++;
+		if (*cmd) {
+			char tmp_cmd[32];
+			strlcpy(tmp_cmd, cmd, sizeof(tmp_cmd));
+			machine_restart(tmp_cmd);
+		} else {
+			machine_restart(NULL);
+		}
+	} else if (!strcmp(cmd, "irqs")) {
+		fiq_debugger_dump_irqs(state);
+	} else if (!strcmp(cmd, "kmsg")) {
+		fiq_debugger_dump_kernel_log(state);
+#endif
+#ifdef CONFIG_ROCKCHIP_DEBUG
+	} else if (!strcmp(cmd, "pcsr")) {
+		rockchip_debug_dump_pcsr(&state->output);
+#endif
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+	} else if (!strcmp(cmd, "version")) {
+		fiq_debugger_printf(&state->output, "%s\n", linux_banner);
+#endif
+	} else if (!strcmp(cmd, "sleep")) {
+		state->no_sleep = false;
+		fiq_debugger_printf(&state->output, "enabling sleep\n");
+	} else if (!strcmp(cmd, "nosleep")) {
+		state->no_sleep = true;
+		fiq_debugger_printf(&state->output, "disabling sleep\n");
+	} else if (!strcmp(cmd, "console")) {
+		fiq_debugger_printf(&state->output, "console mode\n");
+		fiq_debugger_uart_flush(state);
+		state->console_enable = true;
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+		if (sip_fiq_debugger_is_enabled()) {
+			if (state->pdata->enable_debug)
+				state->pdata->enable_debug(state->pdev, false);
+		}
+#endif
+	} else if (!strcmp(cmd, "cpu")) {
+		fiq_debugger_printf(&state->output, "cpu %d\n", state->current_cpu);
+	} else if (!strncmp(cmd, "cpu ", 4)) {
+		unsigned long cpu = 0;
+		if (kstrtoul(cmd + 4, 10, &cpu) == 0)
+			fiq_debugger_switch_cpu(state, cpu);
+		else
+			fiq_debugger_printf(&state->output, "invalid cpu\n");
+
+		fiq_debugger_printf(&state->output, "cpu %d\n", state->current_cpu);
+	} else {
+		if (state->debug_busy) {
+			fiq_debugger_printf(&state->output,
+				"command processor busy. trying to abort.\n");
+			state->debug_abort = -1;
+		} else {
+			strcpy(state->debug_cmd, cmd);
+			state->debug_busy = 1;
+		}
+
+		return true;
+	}
+	if (!state->console_enable)
+		fiq_debugger_prompt(state);
+
+	return signal_helper;
+}
+
+static void fiq_debugger_sleep_timer_expired(struct timer_list *t)
+{
+	struct fiq_debugger_state *state = from_timer(state, t, sleep_timer);
+	unsigned long flags;
+
+	spin_lock_irqsave(&state->sleep_timer_lock, flags);
+	if (state->uart_enabled && !state->no_sleep) {
+		if (state->debug_enable && !state->console_enable) {
+			state->debug_enable = false;
+			fiq_debugger_printf_nfiq(state,
+					"suspending fiq debugger\n");
+		}
+		state->ignore_next_wakeup_irq = true;
+		fiq_debugger_uart_disable(state);
+		state->uart_enabled = false;
+		fiq_debugger_enable_wakeup_irq(state);
+	}
+	__pm_relax(&state->debugger_wake_src);
+	spin_unlock_irqrestore(&state->sleep_timer_lock, flags);
+}
+
+static void fiq_debugger_handle_wakeup(struct fiq_debugger_state *state)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&state->sleep_timer_lock, flags);
+	if (state->wakeup_irq >= 0 && state->ignore_next_wakeup_irq) {
+		state->ignore_next_wakeup_irq = false;
+	} else if (!state->uart_enabled) {
+		__pm_stay_awake(&state->debugger_wake_src);
+		fiq_debugger_uart_enable(state);
+		state->uart_enabled = true;
+		fiq_debugger_disable_wakeup_irq(state);
+		mod_timer(&state->sleep_timer, jiffies + HZ / 2);
+	}
+	spin_unlock_irqrestore(&state->sleep_timer_lock, flags);
+}
+
+static irqreturn_t fiq_debugger_wakeup_irq_handler(int irq, void *dev)
+{
+	struct fiq_debugger_state *state = dev;
+
+	if (!state->no_sleep)
+		fiq_debugger_puts(state, "WAKEUP\n");
+	fiq_debugger_handle_wakeup(state);
+
+	return IRQ_HANDLED;
+}
+
+static
+void fiq_debugger_handle_console_irq_context(struct fiq_debugger_state *state)
+{
+#if defined(CONFIG_FIQ_DEBUGGER_CONSOLE)
+	if (state->tty_port.ops) {
+		int i;
+		int count = fiq_debugger_ringbuf_level(state->tty_rbuf);
+		for (i = 0; i < count; i++) {
+			int c = fiq_debugger_ringbuf_peek(state->tty_rbuf, 0);
+			tty_insert_flip_char(&state->tty_port, c, TTY_NORMAL);
+			if (!fiq_debugger_ringbuf_consume(state->tty_rbuf, 1))
+				pr_warn("fiq tty failed to consume byte\n");
+		}
+		tty_flip_buffer_push(&state->tty_port);
+	}
+#endif
+}
+
+static void fiq_debugger_handle_irq_context(struct fiq_debugger_state *state)
+{
+	if (!state->no_sleep) {
+		unsigned long flags;
+
+		spin_lock_irqsave(&state->sleep_timer_lock, flags);
+		__pm_stay_awake(&state->debugger_wake_src);
+		mod_timer(&state->sleep_timer, jiffies + HZ * 5);
+		spin_unlock_irqrestore(&state->sleep_timer_lock, flags);
+	}
+	fiq_debugger_handle_console_irq_context(state);
+	if (state->debug_busy) {
+		fiq_debugger_irq_exec(state, state->debug_cmd);
+		if (!state->console_enable)
+			fiq_debugger_prompt(state);
+		state->debug_busy = 0;
+	}
+}
+
+static int fiq_debugger_getc(struct fiq_debugger_state *state)
+{
+	if (state->pdata->uart_getc)
+		return state->pdata->uart_getc(state->pdev);
+	else
+		return FIQ_DEBUGGER_NO_CHAR;
+}
+
+static int fiq_debugger_cmd_check_back(struct fiq_debugger_state *state, char c)
+{
+	char *s;
+	int i = 0;
+
+	if (c == 'A') {
+		state->back_pointer = (state->back_pointer - 1) & CMD_COUNT;
+		if (state->back_pointer != state->current_pointer) {
+			s = state->cmd_buf[state->back_pointer];
+			if (*s != 0) {
+				for (i = 0; i < strlen(state->debug_buf) - 1; i++) {
+					fiq_debugger_putc(state, 8);
+					fiq_debugger_putc(state, ' ');
+					fiq_debugger_putc(state, 8);
+				}
+				memset(state->debug_buf, 0, DEBUG_MAX);
+				strcpy(state->debug_buf, s);
+				state->debug_count = strlen(state->debug_buf);
+				fiq_debugger_printf(&state->output, state->debug_buf);
+			} else {
+				state->back_pointer = (state->back_pointer + 1) & CMD_COUNT;
+			}
+
+		} else {
+			state->back_pointer = (state->back_pointer + 1) & CMD_COUNT;
+		}
+	} else if (c == 'B') {
+		if (state->back_pointer != state->current_pointer) {
+			state->back_pointer = (state->back_pointer + 1) & CMD_COUNT;
+			if (state->back_pointer == state->current_pointer) {
+				goto cmd_clear;
+			} else {
+				s = state->cmd_buf[state->back_pointer];
+				if (*s != 0) {
+					for (i = 0; i < strlen(state->debug_buf) - 1; i++) {
+						fiq_debugger_putc(state, 8);
+						fiq_debugger_putc(state, ' ');
+						fiq_debugger_putc(state, 8);
+					}
+					memset(state->debug_buf, 0, DEBUG_MAX);
+					strcpy(state->debug_buf, s);
+					state->debug_count = strlen(state->debug_buf);
+					fiq_debugger_printf(&state->output, state->debug_buf);
+				}
+			}
+		} else {
+cmd_clear:
+			for (i = 0; i < strlen(state->debug_buf) - 1; i++) {
+				fiq_debugger_putc(state, 8);
+				fiq_debugger_putc(state, ' ');
+				fiq_debugger_putc(state, 8);
+			}
+			memset(state->debug_buf, 0, DEBUG_MAX);
+			state->debug_count = 0;
+		}
+	}
+	return 0;
+}
+
+static void fiq_debugger_cmd_tab(struct fiq_debugger_state *state)
+{
+	int i, j;
+	int count = 0;
+
+	for (i = 0; i < ARRAY_SIZE(cmd_buf); i++)
+		cmd_buf[i][15] = 1;
+
+	for (j = 1; j <= strlen(state->debug_buf); j++) {
+		count = 0;
+		for (i = 0; i < ARRAY_SIZE(cmd_buf); i++) {
+			if (cmd_buf[i][15] == 1) {
+				if (strncmp(state->debug_buf, cmd_buf[i], j))
+					cmd_buf[i][15] = 0;
+				else
+					count++;
+			}
+		}
+		if (count == 0)
+			break;
+	}
+
+	if (count == 1) {
+		for (i = 0; i < ARRAY_SIZE(cmd_buf); i++) {
+			if (cmd_buf[i][15] == 1)
+				break;
+		}
+
+		for (j = 0; j < strlen(state->debug_buf); j++) {
+			fiq_debugger_putc(state, 8);
+			fiq_debugger_putc(state, ' ');
+			fiq_debugger_putc(state, 8);
+		}
+		memset(state->debug_buf, 0, DEBUG_MAX);
+		strcpy(state->debug_buf, cmd_buf[i]);
+		state->debug_count = strlen(state->debug_buf);
+		fiq_debugger_printf(&state->output, state->debug_buf);
+	}
+}
+
+static bool fiq_debugger_handle_uart_interrupt(struct fiq_debugger_state *state,
+			int this_cpu, const struct pt_regs *regs, void *svc_sp)
+{
+	int c;
+	static int last_c;
+	int count = 0;
+	bool signal_helper = false;
+
+	if (state->current_cpu == -1)
+		state->current_cpu = this_cpu;
+
+	if (this_cpu != state->current_cpu) {
+		if (state->in_fiq)
+			return false;
+
+		if (atomic_inc_return(&state->unhandled_fiq_count) !=
+					MAX_UNHANDLED_FIQ_COUNT)
+			return false;
+
+		fiq_debugger_printf(&state->output,
+			"fiq_debugger: cpu %d not responding, "
+			"reverting to cpu %d\n", state->current_cpu,
+			this_cpu);
+
+		atomic_set(&state->unhandled_fiq_count, 0);
+		state->current_cpu = this_cpu;
+		return false;
+	}
+
+	state->in_fiq = true;
+
+	while ((c = fiq_debugger_getc(state)) != FIQ_DEBUGGER_NO_CHAR) {
+		count++;
+		if (!state->debug_enable) {
+			if ((c == 13) || (c == 10)) {
+				state->debug_enable = true;
+				state->debug_count = 0;
+				fiq_debugger_prompt(state);
+			}
+		} else if (c == FIQ_DEBUGGER_BREAK) {
+			state->console_enable = false;
+#ifdef CONFIG_ARCH_ROCKCHIP
+			fiq_debugger_puts(state, "\nWelcome to ");
+#endif
+			if (fiq_debugger_have_fiq(state))
+				fiq_debugger_puts(state,
+						  "fiq debugger mode\n");
+			else
+				fiq_debugger_puts(state,
+						  "irq debugger mode\n");
+			state->debug_count = 0;
+#ifdef CONFIG_ARCH_ROCKCHIP
+			fiq_debugger_puts(state, "Enter ? to get command help\n");
+			state->back_pointer = CMD_COUNT;
+			state->current_pointer = CMD_COUNT;
+			memset(state->cmd_buf, 0, (CMD_COUNT + 1) * DEBUG_MAX);
+#endif
+
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+			if (sip_fiq_debugger_is_enabled()) {
+				if (state->pdata->enable_debug)
+					state->pdata->enable_debug(state->pdev,
+								   true);
+			}
+#endif
+			fiq_debugger_prompt(state);
+#ifdef CONFIG_FIQ_DEBUGGER_CONSOLE
+			fiq_debugger_ringbuf_push(state->tty_rbuf, 8);
+			fiq_debugger_ringbuf_push(state->tty_rbuf, 8);
+#endif
+#ifdef CONFIG_FIQ_DEBUGGER_CONSOLE
+		} else if (state->console_enable && state->tty_rbuf) {
+			fiq_debugger_ringbuf_push(state->tty_rbuf, c);
+			signal_helper = true;
+#endif
+#ifdef CONFIG_ARCH_ROCKCHIP
+		} else if (last_c == '[' && (c == 'A' || c == 'B' || c == 'C' || c == 'D')) {
+			if (state->debug_count > 0) {
+				state->debug_count--;
+				fiq_debugger_putc(state, 8);
+				fiq_debugger_putc(state, ' ');
+				fiq_debugger_putc(state, 8);
+			}
+			fiq_debugger_cmd_check_back(state, c);
+		} else if (c == 9) {
+			fiq_debugger_cmd_tab(state);
+#endif
+		} else if ((c >= ' ') && (c < 127)) {
+			if (state->debug_count < (DEBUG_MAX - 1)) {
+				state->debug_buf[state->debug_count++] = c;
+				fiq_debugger_putc(state, c);
+			}
+		} else if ((c == 8) || (c == 127)) {
+			if (state->debug_count > 0) {
+				state->debug_count--;
+				fiq_debugger_putc(state, 8);
+				fiq_debugger_putc(state, ' ');
+				fiq_debugger_putc(state, 8);
+			}
+		} else if ((c == 13) || (c == 10)) {
+			if (c == '\r' || (c == '\n' && last_c != '\r')) {
+				fiq_debugger_putc(state, '\r');
+				fiq_debugger_putc(state, '\n');
+			}
+			if (state->debug_count) {
+				state->debug_buf[state->debug_count] = 0;
+				state->debug_count = 0;
+				signal_helper |=
+					fiq_debugger_fiq_exec(state,
+							state->debug_buf,
+							regs, svc_sp);
+#ifdef CONFIG_ARCH_ROCKCHIP
+				if (signal_helper == false) {
+					state->current_pointer =
+							(state->current_pointer - 1) & CMD_COUNT;
+					if (strcmp(state->cmd_buf[state->current_pointer], state->debug_buf)) {
+						state->current_pointer =
+							(state->current_pointer + 1) & CMD_COUNT;
+						memset(state->cmd_buf[state->current_pointer], 0, DEBUG_MAX);
+						strcpy(state->cmd_buf[state->current_pointer], state->debug_buf);
+					}
+					memset(state->debug_buf, 0, DEBUG_MAX);
+					state->current_pointer =
+						(state->current_pointer + 1) & CMD_COUNT;
+					state->back_pointer =
+						state->current_pointer;
+				}
+#endif
+			} else {
+				fiq_debugger_prompt(state);
+			}
+		}
+		last_c = c;
+	}
+	if (!state->console_enable)
+		fiq_debugger_uart_flush(state);
+	if (state->pdata->fiq_ack)
+		state->pdata->fiq_ack(state->pdev, state->fiq);
+
+	/* poke sleep timer if necessary */
+	if (state->debug_enable && !state->no_sleep)
+		signal_helper = true;
+
+	atomic_set(&state->unhandled_fiq_count, 0);
+	state->in_fiq = false;
+
+	return signal_helper;
+}
+
+#ifdef CONFIG_FIQ_GLUE
+static void fiq_debugger_fiq(struct fiq_glue_handler *h,
+		void *regs, void *svc_sp)
+{
+	struct fiq_debugger_state *state =
+		container_of(h, struct fiq_debugger_state, handler);
+	unsigned int this_cpu = THREAD_INFO(svc_sp)->cpu;
+	bool need_irq;
+
+	need_irq = fiq_debugger_handle_uart_interrupt(state, this_cpu, regs,
+			svc_sp);
+	if (need_irq)
+		fiq_debugger_force_irq(state);
+}
+#endif
+
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+void fiq_debugger_fiq(void *regs, u32 cpu)
+{
+	struct fiq_debugger_state *state = g_state;
+	bool need_irq;
+
+	if (!state)
+		return;
+
+	need_irq = fiq_debugger_handle_uart_interrupt(state, cpu, regs,
+						      current_thread_info());
+	if (need_irq)
+		fiq_debugger_force_irq(state);
+}
+EXPORT_SYMBOL(fiq_debugger_fiq);
+#endif
+
+/*
+ * When not using FIQs, we only use this single interrupt as an entry point.
+ * This just effectively takes over the UART interrupt and does all the work
+ * in this context.
+ */
+static irqreturn_t fiq_debugger_uart_irq(int irq, void *dev)
+{
+	struct fiq_debugger_state *state = dev;
+	bool not_done;
+
+	fiq_debugger_handle_wakeup(state);
+
+	/* handle the debugger irq in regular context */
+	not_done = fiq_debugger_handle_uart_interrupt(state, smp_processor_id(),
+#ifdef CONFIG_NO_GKI
+					      get_irq_regs(),
+#else
+					      NULL,
+#endif
+					      current_thread_info());
+	if (not_done)
+		fiq_debugger_force_irq(state);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * If FIQs are used, not everything can happen in fiq context.
+ * FIQ handler does what it can and then signals this interrupt to finish the
+ * job in irq context.
+ */
+static irqreturn_t fiq_debugger_signal_irq(int irq, void *dev)
+{
+	struct fiq_debugger_state *state = dev;
+
+	if (state->pdata->force_irq_ack)
+		state->pdata->force_irq_ack(state->pdev, state->signal_irq);
+
+	fiq_debugger_handle_irq_context(state);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_FIQ_GLUE
+static void fiq_debugger_resume(struct fiq_glue_handler *h)
+{
+	struct fiq_debugger_state *state =
+		container_of(h, struct fiq_debugger_state, handler);
+	if (state->pdata->uart_resume)
+		state->pdata->uart_resume(state->pdev);
+}
+#endif
+
+#if defined(CONFIG_FIQ_DEBUGGER_CONSOLE)
+static struct tty_driver *fiq_debugger_console_device(struct console *co, int *index)
+{
+	*index = co->index;
+	return fiq_tty_driver;
+}
+
+static void fiq_debugger_console_write(struct console *co,
+				const char *s, unsigned int count)
+{
+	struct fiq_debugger_state *state;
+	unsigned long flags;
+
+	state = container_of(co, struct fiq_debugger_state, console);
+
+	if (!state->console_enable && !state->syslog_dumping)
+		return;
+
+#ifdef CONFIG_RK_CONSOLE_THREAD
+	if (state->pdata->console_write) {
+		state->pdata->console_write(state->pdev, s, count);
+		return;
+	}
+#endif
+
+	fiq_debugger_uart_enable(state);
+	spin_lock_irqsave(&state->console_lock, flags);
+	while (count--) {
+		if (*s == '\n')
+			fiq_debugger_putc(state, '\r');
+		fiq_debugger_putc(state, *s++);
+	}
+	fiq_debugger_uart_flush(state);
+	spin_unlock_irqrestore(&state->console_lock, flags);
+	fiq_debugger_uart_disable(state);
+}
+
+static struct console fiq_debugger_console = {
+	.name = "ttyFIQ",
+	.device = fiq_debugger_console_device,
+	.write = fiq_debugger_console_write,
+	.flags = CON_PRINTBUFFER | CON_ANYTIME | CON_ENABLED,
+};
+
+static int fiq_tty_open(struct tty_struct *tty, struct file *filp)
+{
+	int line = tty->index;
+	struct fiq_debugger_state **states = tty->driver->driver_state;
+	struct fiq_debugger_state *state = states[line];
+
+	return tty_port_open(&state->tty_port, tty, filp);
+}
+
+static void fiq_tty_close(struct tty_struct *tty, struct file *filp)
+{
+	tty_port_close(tty->port, tty, filp);
+}
+
+void fiq_tty_wake_up(struct platform_device *pdev)
+{
+	struct fiq_debugger_state *state = platform_get_drvdata(pdev);
+
+	if (tty_port_initialized(&state->tty_port))
+		tty_port_tty_wakeup(&state->tty_port);
+}
+EXPORT_SYMBOL_GPL(fiq_tty_wake_up);
+
+static int fiq_tty_write(struct tty_struct *tty, const unsigned char *buf, int count)
+{
+	int i;
+	int line = tty->index;
+	struct fiq_debugger_state **states = tty->driver->driver_state;
+	struct fiq_debugger_state *state = states[line];
+
+	if (!state->console_enable)
+		return count;
+
+#ifdef CONFIG_RK_CONSOLE_THREAD
+	if (state->pdata->tty_write)
+		return state->pdata->tty_write(state->pdev, buf, count);
+#endif
+
+	fiq_debugger_uart_enable(state);
+#ifndef CONFIG_RK_CONSOLE_THREAD
+	spin_lock_irq(&state->console_lock);
+#endif
+	for (i = 0; i < count; i++)
+		fiq_debugger_putc(state, *buf++);
+#ifndef CONFIG_RK_CONSOLE_THREAD
+	spin_unlock_irq(&state->console_lock);
+#endif
+	fiq_debugger_uart_disable(state);
+
+	return count;
+}
+
+static unsigned int fiq_tty_write_room(struct tty_struct *tty)
+{
+#ifdef CONFIG_RK_CONSOLE_THREAD
+	int line = tty->index;
+	struct fiq_debugger_state **states = tty->driver->driver_state;
+	struct fiq_debugger_state *state = states[line];
+
+	if (state->pdata->write_room)
+		return state->pdata->write_room(state->pdev);
+#endif
+	return 2048;
+}
+
+#ifdef CONFIG_CONSOLE_POLL
+static int fiq_tty_poll_init(struct tty_driver *driver, int line, char *options)
+{
+	return 0;
+}
+
+static int fiq_tty_poll_get_char(struct tty_driver *driver, int line)
+{
+	struct fiq_debugger_state **states = driver->driver_state;
+	struct fiq_debugger_state *state = states[line];
+	int c = NO_POLL_CHAR;
+
+	fiq_debugger_uart_enable(state);
+	if (fiq_debugger_have_fiq(state)) {
+#ifdef CONFIG_FIQ_DEBUGGER_CONSOLE
+		int count = fiq_debugger_ringbuf_level(state->tty_rbuf);
+		if (count > 0) {
+			c = fiq_debugger_ringbuf_peek(state->tty_rbuf, 0);
+			fiq_debugger_ringbuf_consume(state->tty_rbuf, 1);
+		}
+#endif
+	} else {
+		c = fiq_debugger_getc(state);
+		if (c == FIQ_DEBUGGER_NO_CHAR)
+			c = NO_POLL_CHAR;
+	}
+	fiq_debugger_uart_disable(state);
+
+	return c;
+}
+
+static void fiq_tty_poll_put_char(struct tty_driver *driver, int line, char ch)
+{
+	struct fiq_debugger_state **states = driver->driver_state;
+	struct fiq_debugger_state *state = states[line];
+	fiq_debugger_uart_enable(state);
+	fiq_debugger_putc(state, ch);
+	fiq_debugger_uart_disable(state);
+}
+#endif
+
+#ifdef CONFIG_PROC_FS
+static int fiq_tty_proc_show(struct seq_file *m, void *v)
+{
+	struct tty_driver *driver = m->private;
+	struct fiq_debugger_state **states = driver->driver_state;
+	struct fiq_debugger_state *state;
+	int i;
+
+	seq_puts(m, "fiq-debugger driver\n");
+	for (i = 0; i < MAX_FIQ_DEBUGGER_PORTS; i++) {
+		state = states[i];
+		if (!state)
+			continue;
+
+		seq_printf(m, "%d:", i);
+		seq_printf(m, " state:%d", state->console_enable);
+		seq_putc(m, '\n');
+	}
+	return 0;
+}
+#endif
+
+static const struct tty_port_operations fiq_tty_port_ops;
+
+static const struct tty_operations fiq_tty_driver_ops = {
+	.write = fiq_tty_write,
+	.write_room = fiq_tty_write_room,
+	.open = fiq_tty_open,
+	.close = fiq_tty_close,
+#ifdef CONFIG_CONSOLE_POLL
+	.poll_init = fiq_tty_poll_init,
+	.poll_get_char = fiq_tty_poll_get_char,
+	.poll_put_char = fiq_tty_poll_put_char,
+#endif
+#ifdef CONFIG_PROC_FS
+	.proc_show = fiq_tty_proc_show,
+#endif
+};
+
+static int fiq_debugger_tty_init(void)
+{
+	int ret;
+	struct fiq_debugger_state **states = NULL;
+	struct tty_driver *drv;
+
+	states = kzalloc(sizeof(*states) * MAX_FIQ_DEBUGGER_PORTS, GFP_KERNEL);
+	if (!states) {
+		pr_err("Failed to allocate fiq debugger state structres\n");
+		return -ENOMEM;
+	}
+
+	drv = tty_alloc_driver(MAX_FIQ_DEBUGGER_PORTS, TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);
+	if (IS_ERR(drv)) {
+		pr_err("Failed to allocate fiq debugger tty\n");
+		ret = -ENOMEM;
+		goto err_free_state;
+	}
+	fiq_tty_driver = drv;
+
+	fiq_tty_driver->owner		= THIS_MODULE;
+	fiq_tty_driver->driver_name	= "fiq-debugger";
+	fiq_tty_driver->name		= "ttyFIQ";
+	fiq_tty_driver->type		= TTY_DRIVER_TYPE_SERIAL;
+	fiq_tty_driver->subtype		= SERIAL_TYPE_NORMAL;
+	fiq_tty_driver->init_termios	= tty_std_termios;
+	fiq_tty_driver->driver_state	= states;
+
+	fiq_tty_driver->init_termios.c_cflag =
+					B115200 | CS8 | CREAD | HUPCL | CLOCAL;
+	fiq_tty_driver->init_termios.c_ispeed = 115200;
+	fiq_tty_driver->init_termios.c_ospeed = 115200;
+
+	tty_set_operations(fiq_tty_driver, &fiq_tty_driver_ops);
+
+	ret = tty_register_driver(fiq_tty_driver);
+	if (ret) {
+		pr_err("Failed to register fiq tty: %d\n", ret);
+		goto err_free_tty;
+	}
+
+	pr_info("Registered FIQ tty driver\n");
+	return 0;
+
+err_free_tty:
+	tty_driver_kref_put(fiq_tty_driver);
+	fiq_tty_driver = NULL;
+err_free_state:
+	kfree(states);
+	return ret;
+}
+
+static int fiq_debugger_tty_init_one(struct fiq_debugger_state *state)
+{
+	int ret;
+	struct device *tty_dev;
+	struct fiq_debugger_state **states = fiq_tty_driver->driver_state;
+
+	states[state->pdev->id] = state;
+
+	state->tty_rbuf = fiq_debugger_ringbuf_alloc(1024);
+	if (!state->tty_rbuf) {
+		pr_err("Failed to allocate fiq debugger ringbuf\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	tty_port_init(&state->tty_port);
+	state->tty_port.ops = &fiq_tty_port_ops;
+
+	tty_dev = tty_port_register_device(&state->tty_port, fiq_tty_driver,
+					   state->pdev->id, &state->pdev->dev);
+	if (IS_ERR(tty_dev)) {
+		pr_err("Failed to register fiq debugger tty device\n");
+		ret = PTR_ERR(tty_dev);
+		goto err;
+	}
+
+	device_set_wakeup_capable(tty_dev, 1);
+
+	pr_info("Registered fiq debugger ttyFIQ%d\n", state->pdev->id);
+
+	return 0;
+
+err:
+	fiq_debugger_ringbuf_free(state->tty_rbuf);
+	state->tty_rbuf = NULL;
+	return ret;
+}
+#endif
+
+static int fiq_debugger_dev_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct fiq_debugger_state *state = platform_get_drvdata(pdev);
+
+	if (state->pdata->uart_dev_suspend)
+		return state->pdata->uart_dev_suspend(pdev);
+	return 0;
+}
+
+static int fiq_debugger_dev_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct fiq_debugger_state *state = platform_get_drvdata(pdev);
+
+	if (state->pdata->uart_dev_resume)
+		return state->pdata->uart_dev_resume(pdev);
+	return 0;
+}
+
+static int fiq_debugger_cpu_offine_migrate_irq(unsigned int cpu)
+{
+	if (g_state && cpu == g_state->current_cpu) {
+		unsigned int new_cpu = cpumask_any_but(cpu_online_mask, cpu);
+
+		if (new_cpu < nr_cpu_ids)
+			g_state->current_cpu = new_cpu;
+	}
+
+	return 0;
+}
+
+static int fiq_debugger_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct fiq_debugger_pdata *pdata = dev_get_platdata(&pdev->dev);
+	struct fiq_debugger_state *state;
+	int fiq;
+	int uart_irq;
+	enum cpuhp_state cs = -1;
+
+	if (pdev->id >= MAX_FIQ_DEBUGGER_PORTS)
+		return -EINVAL;
+
+	if (!pdata->uart_getc || !pdata->uart_putc)
+		return -EINVAL;
+	if ((pdata->uart_enable && !pdata->uart_disable) ||
+	    (!pdata->uart_enable && pdata->uart_disable))
+		return -EINVAL;
+
+	fiq = platform_get_irq_byname(pdev, "fiq");
+	uart_irq = platform_get_irq_byname(pdev, "uart_irq");
+
+#ifndef CONFIG_ARCH_ROCKCHIP
+	/* uart_irq mode and fiq mode are mutually exclusive, but one of them
+	 * is required */
+	if ((uart_irq < 0 && fiq < 0) || (uart_irq >= 0 && fiq >= 0))
+		return -EINVAL;
+	if (fiq >= 0 && !pdata->fiq_enable)
+		return -EINVAL;
+#endif
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	state->output.printf = fiq_debugger_printf;
+	timer_setup(&state->sleep_timer, fiq_debugger_sleep_timer_expired, 0);
+	state->pdata = pdata;
+	state->pdev = pdev;
+	state->no_sleep = initial_no_sleep;
+	state->debug_enable = initial_debug_enable;
+	state->console_enable = initial_console_enable;
+	state->current_cpu = -1;
+
+	state->fiq = fiq;
+	state->uart_irq = uart_irq;
+	state->signal_irq = platform_get_irq_byname(pdev, "signal");
+	state->wakeup_irq = platform_get_irq_byname(pdev, "wakeup");
+
+	INIT_WORK(&state->work, fiq_debugger_work);
+	spin_lock_init(&state->work_lock);
+
+	platform_set_drvdata(pdev, state);
+
+	spin_lock_init(&state->sleep_timer_lock);
+
+	if (state->wakeup_irq < 0 && fiq_debugger_have_fiq(state))
+		state->no_sleep = true;
+	state->ignore_next_wakeup_irq = !state->no_sleep;
+
+	state->debugger_wake_src.name = "serial-debug";
+	wakeup_source_add(&state->debugger_wake_src);
+
+#ifdef CONFIG_ARCH_ROCKCHIP
+	if (uart_irq < 0 && fiq < 0)
+		goto console_out;
+#endif
+
+	state->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(state->clk))
+		state->clk = NULL;
+
+	/* do not call pdata->uart_enable here since uart_init may still
+	 * need to do some initialization before uart_enable can work.
+	 * So, only try to manage the clock during init.
+	 */
+	if (state->clk)
+		clk_enable(state->clk);
+
+	if (fiq_debugger_have_fiq(state)) {
+#ifdef CONFIG_FIQ_GLUE
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+		if (sip_fiq_debugger_is_enabled() ||
+		    sdei_fiq_debugger_is_enabled()) {
+		} else
+#endif
+		{
+		state->handler.fiq = fiq_debugger_fiq;
+		state->handler.resume = fiq_debugger_resume;
+		ret = fiq_glue_register_handler(&state->handler);
+		if (ret) {
+			pr_err("%s: could not install fiq handler\n", __func__);
+			goto err_register_irq;
+		}
+#ifdef CONFIG_ARCH_ROCKCHIP
+		/* set state->fiq to secure state, so fiq is available */
+		gic_set_irq_secure(irq_get_irq_data(state->fiq));
+		/*
+		* set state->fiq priority a little higher than other
+		* interrupts (normal is 0xa0)
+		*/
+		gic_set_irq_priority(irq_get_irq_data(state->fiq), 0x90);
+#endif
+		pdata->fiq_enable(pdev, state->fiq, 1);
+		}
+#endif
+	} else {
+		irq_set_status_flags(state->uart_irq, IRQ_NOAUTOEN);
+
+		if (IS_ENABLED(CONFIG_NO_GKI))
+			ret = request_nmi(state->uart_irq, fiq_debugger_uart_irq,
+					  IRQF_PERCPU, "debug", state);
+		else
+			ret = -EINVAL;
+		if (ret) {
+			pr_err("%s: could not install nmi irq handler\n", __func__);
+			irq_clear_status_flags(state->uart_irq, IRQ_NOAUTOEN);
+			ret = request_irq(state->uart_irq, fiq_debugger_uart_irq,
+					  IRQF_NO_SUSPEND | IRQF_NOBALANCING, "debug", state);
+		} else {
+			enable_nmi(state->uart_irq);
+		}
+
+		if (ret) {
+			pr_err("%s: could not install irq handler\n", __func__);
+			goto err_register_irq;
+		}
+
+		/* for irq-only mode, we want this irq to wake us up, if it
+		 * can.
+		 */
+		enable_irq_wake(state->uart_irq);
+
+		ret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
+						"soc/fiq_debugger",
+						NULL,
+						fiq_debugger_cpu_offine_migrate_irq);
+		if (ret < 0)
+			pr_err("%s: could not setup cpu offine handler\n", __func__);
+		else
+			cs = ret;
+	}
+
+	if (state->signal_irq >= 0) {
+		ret = request_irq(state->signal_irq, fiq_debugger_signal_irq,
+			  IRQF_TRIGGER_RISING, "debug-signal", state);
+		if (ret)
+			pr_err("serial_debugger: could not install signal_irq");
+	}
+
+	if (state->wakeup_irq >= 0) {
+		ret = request_irq(state->wakeup_irq,
+				  fiq_debugger_wakeup_irq_handler,
+				  IRQF_TRIGGER_FALLING,
+				  "debug-wakeup", state);
+		if (ret) {
+			pr_err("serial_debugger: "
+				"could not install wakeup irq\n");
+			state->wakeup_irq = -1;
+		} else {
+			ret = enable_irq_wake(state->wakeup_irq);
+			if (ret) {
+				pr_err("serial_debugger: "
+					"could not enable wakeup\n");
+				state->wakeup_irq_no_set_wake = true;
+			}
+		}
+	}
+	if (state->no_sleep)
+		fiq_debugger_handle_wakeup(state);
+
+	if (pdata->uart_init) {
+		ret = pdata->uart_init(pdev);
+		if (ret)
+			goto err_uart_init;
+	}
+
+	if (state->clk)
+		clk_disable(state->clk);
+#ifdef CONFIG_ARCH_ROCKCHIP
+console_out:
+#endif
+#if defined(CONFIG_FIQ_DEBUGGER_CONSOLE)
+	spin_lock_init(&state->console_lock);
+	state->console = fiq_debugger_console;
+	state->console.index = pdev->id;
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+	if (!console_set_on_cmdline)
+		add_preferred_console(state->console.name,
+			state->console.index, NULL);
+#endif
+	register_console(&state->console);
+	fiq_debugger_tty_init_one(state);
+#endif
+
+	/* switch to cpu0 default */
+	fiq_debugger_switch_cpu(state, 0);
+	g_state = state;
+	return 0;
+
+err_register_irq:
+	if (pdata->uart_free)
+		pdata->uart_free(pdev);
+err_uart_init:
+	if (state->clk)
+		clk_disable(state->clk);
+	if (state->clk)
+		clk_put(state->clk);
+	if (cs >= 0)
+		cpuhp_remove_state_nocalls(cs);
+	wakeup_source_remove(&state->debugger_wake_src);
+	__pm_relax(&state->debugger_wake_src);
+	platform_set_drvdata(pdev, NULL);
+	kfree(state);
+	return ret;
+}
+
+static const struct dev_pm_ops fiq_debugger_dev_pm_ops = {
+	.suspend	= fiq_debugger_dev_suspend,
+	.resume		= fiq_debugger_dev_resume,
+};
+
+static struct platform_driver fiq_debugger_driver = {
+	.probe	= fiq_debugger_probe,
+	.driver	= {
+		.name	= "fiq_debugger",
+		.pm	= &fiq_debugger_dev_pm_ops,
+	},
+};
+
+#if defined(CONFIG_FIQ_DEBUGGER_UART_OVERLAY)
+int fiq_debugger_uart_overlay(void)
+{
+	struct device_node *onp = of_find_node_by_path("/uart_overlay@0");
+	int ret;
+
+	if (!onp) {
+		pr_err("serial_debugger: uart overlay not found\n");
+		return -ENODEV;
+	}
+
+	ret = of_overlay_create(onp);
+	if (ret < 0) {
+		pr_err("serial_debugger: fail to create overlay: %d\n", ret);
+		of_node_put(onp);
+		return ret;
+	}
+
+	pr_info("serial_debugger: uart overlay applied\n");
+	return 0;
+}
+#endif
+
+static int __init fiq_debugger_init(void)
+{
+	if (fiq_debugger_disable) {
+		pr_err("serial_debugger: disabled\n");
+		return -ENODEV;
+	}
+#if defined(CONFIG_FIQ_DEBUGGER_CONSOLE)
+	fiq_debugger_tty_init();
+#endif
+#if defined(CONFIG_FIQ_DEBUGGER_UART_OVERLAY)
+	fiq_debugger_uart_overlay();
+#endif
+	return platform_driver_register(&fiq_debugger_driver);
+}
+
+postcore_initcall(fiq_debugger_init);
+
+static void __exit fiq_debugger_exit(void)
+{
+	platform_driver_unregister(&fiq_debugger_driver);
+}
+module_exit(fiq_debugger_exit);
+
+MODULE_DESCRIPTION("FIQ Debugger");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:fiq-debugger");

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/fiq_debugger.h
@@ -0,0 +1,81 @@
+/*
+ * drivers/staging/android/fiq_debugger/fiq_debugger.h
+ *
+ * Copyright (C) 2010 Google, Inc.
+ * Author: Colin Cross <ccross@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ARCH_ARM_MACH_TEGRA_FIQ_DEBUGGER_H_
+#define _ARCH_ARM_MACH_TEGRA_FIQ_DEBUGGER_H_
+
+#include <linux/serial_core.h>
+
+#define FIQ_DEBUGGER_NO_CHAR NO_POLL_CHAR
+#define FIQ_DEBUGGER_BREAK 0x00ff0100
+
+#define FIQ_DEBUGGER_FIQ_IRQ_NAME	"fiq"
+#define FIQ_DEBUGGER_SIGNAL_IRQ_NAME	"signal"
+#define FIQ_DEBUGGER_WAKEUP_IRQ_NAME	"wakeup"
+
+/**
+ * struct fiq_debugger_pdata - fiq debugger platform data
+ * @uart_resume:	used to restore uart state right before enabling
+ *			the fiq.
+ * @uart_enable:	Do the work necessary to communicate with the uart
+ *			hw (enable clocks, etc.). This must be ref-counted.
+ * @uart_disable:	Do the work necessary to disable the uart hw
+ *			(disable clocks, etc.). This must be ref-counted.
+ * @uart_dev_suspend:	called during PM suspend, generally not needed
+ *			for real fiq mode debugger.
+ * @uart_dev_resume:	called during PM resume, generally not needed
+ *			for real fiq mode debugger.
+ */
+struct fiq_debugger_pdata {
+	int (*uart_init)(struct platform_device *pdev);
+	void (*uart_free)(struct platform_device *pdev);
+	int (*uart_resume)(struct platform_device *pdev);
+	int (*uart_getc)(struct platform_device *pdev);
+	void (*uart_putc)(struct platform_device *pdev, unsigned int c);
+	void (*uart_flush)(struct platform_device *pdev);
+	void (*uart_enable)(struct platform_device *pdev);
+	void (*uart_disable)(struct platform_device *pdev);
+
+	int (*uart_dev_suspend)(struct platform_device *pdev);
+	int (*uart_dev_resume)(struct platform_device *pdev);
+
+	void (*fiq_enable)(struct platform_device *pdev, unsigned int fiq,
+								bool enable);
+	void (*fiq_ack)(struct platform_device *pdev, unsigned int fiq);
+
+	void (*force_irq)(struct platform_device *pdev, unsigned int irq);
+	void (*force_irq_ack)(struct platform_device *pdev, unsigned int irq);
+
+#ifdef CONFIG_RK_CONSOLE_THREAD
+	void (*console_write)(struct platform_device *pdev, const char *s,
+			      unsigned int count);
+	int (*tty_write)(struct platform_device *pdev, const char *s, int count);
+	int (*write_room)(struct platform_device *pdev);
+#endif
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+	void (*switch_cpu)(struct platform_device *pdev, u32 cpu);
+	void (*enable_debug)(struct platform_device *pdev, bool val);
+#endif
+};
+
+#ifdef CONFIG_FIQ_GLUE
+void gic_set_irq_secure(struct irq_data *d);
+void gic_set_irq_priority(struct irq_data *d, u8 pri);
+#endif
+
+void fiq_tty_wake_up(struct platform_device *pdev);
+#endif

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/fiq_debugger_arm.c
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ * Author: Colin Cross <ccross@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/ptrace.h>
+#include <linux/uaccess.h>
+
+#include <asm/stacktrace.h>
+
+#include "fiq_debugger_priv.h"
+
+static char *mode_name(unsigned cpsr)
+{
+	switch (cpsr & MODE_MASK) {
+	case USR_MODE: return "USR";
+	case FIQ_MODE: return "FIQ";
+	case IRQ_MODE: return "IRQ";
+	case SVC_MODE: return "SVC";
+	case ABT_MODE: return "ABT";
+	case UND_MODE: return "UND";
+	case SYSTEM_MODE: return "SYS";
+	default: return "???";
+	}
+}
+
+void fiq_debugger_dump_pc(struct fiq_debugger_output *output,
+		const struct pt_regs *regs)
+{
+	output->printf(output, " pc %08x cpsr %08x mode %s\n",
+		regs->ARM_pc, regs->ARM_cpsr, mode_name(regs->ARM_cpsr));
+}
+
+void fiq_debugger_dump_regs(struct fiq_debugger_output *output,
+		const struct pt_regs *regs)
+{
+	output->printf(output,
+			" r0 %08x  r1 %08x  r2 %08x  r3 %08x\n",
+			regs->ARM_r0, regs->ARM_r1, regs->ARM_r2, regs->ARM_r3);
+	output->printf(output,
+			" r4 %08x  r5 %08x  r6 %08x  r7 %08x\n",
+			regs->ARM_r4, regs->ARM_r5, regs->ARM_r6, regs->ARM_r7);
+	output->printf(output,
+			" r8 %08x  r9 %08x r10 %08x r11 %08x  mode %s\n",
+			regs->ARM_r8, regs->ARM_r9, regs->ARM_r10, regs->ARM_fp,
+			mode_name(regs->ARM_cpsr));
+	output->printf(output,
+			" ip %08x  sp %08x  lr %08x  pc %08x cpsr %08x\n",
+			regs->ARM_ip, regs->ARM_sp, regs->ARM_lr, regs->ARM_pc,
+			regs->ARM_cpsr);
+}
+
+struct mode_regs {
+	unsigned long sp_svc;
+	unsigned long lr_svc;
+	unsigned long spsr_svc;
+
+	unsigned long sp_abt;
+	unsigned long lr_abt;
+	unsigned long spsr_abt;
+
+	unsigned long sp_und;
+	unsigned long lr_und;
+	unsigned long spsr_und;
+
+	unsigned long sp_irq;
+	unsigned long lr_irq;
+	unsigned long spsr_irq;
+
+	unsigned long r8_fiq;
+	unsigned long r9_fiq;
+	unsigned long r10_fiq;
+	unsigned long r11_fiq;
+	unsigned long r12_fiq;
+	unsigned long sp_fiq;
+	unsigned long lr_fiq;
+	unsigned long spsr_fiq;
+};
+
+static void __naked get_mode_regs(struct mode_regs *regs)
+{
+	asm volatile (
+	"mrs	r1, cpsr\n"
+#ifdef CONFIG_THUMB2_KERNEL
+	"mov	r3, #0xd3 @(SVC_MODE | PSR_I_BIT | PSR_F_BIT)\n"
+	"msr	cpsr_c, r3\n"
+	"str	r13, [r0], 4\n"
+	"str	r14, [r0], 4\n"
+	"mrs	r2, spsr\n"
+	"mov	r3, #0xd7 @(ABT_MODE | PSR_I_BIT | PSR_F_BIT)\n"
+	"msr	cpsr_c, r3\n"
+	"str	r2, [r0], 4\n"
+	"str	r13, [r0], 4\n"
+	"str	r14, [r0], 4\n"
+	"mrs	r2, spsr\n"
+	"mov	r3, #0xdb @(UND_MODE | PSR_I_BIT | PSR_F_BIT)\n"
+	"msr	cpsr_c, r3\n"
+	"str	r2, [r0], 4\n"
+	"str	r13, [r0], 4\n"
+	"str	r14, [r0], 4\n"
+	"mrs	r2, spsr\n"
+	"mov	r3, #0xd2 @(IRQ_MODE | PSR_I_BIT | PSR_F_BIT)\n"
+	"msr	cpsr_c, r3\n"
+	"str	r2, [r0], 4\n"
+	"str	r13, [r0], 4\n"
+	"str	r14, [r0], 4\n"
+	"mrs	r2, spsr\n"
+	"mov	r3, #0xd1 @(FIQ_MODE | PSR_I_BIT | PSR_F_BIT)\n"
+	"msr	cpsr_c, r3\n"
+	"stmia	r0!, {r2, r8 - r12}\n"
+	"str	r13, [r0], 4\n"
+	"str	r14, [r0], 4\n"
+#else
+	"msr	cpsr_c, #0xd3 @(SVC_MODE | PSR_I_BIT | PSR_F_BIT)\n"
+	"stmia	r0!, {r13 - r14}\n"
+	"mrs	r2, spsr\n"
+	"msr	cpsr_c, #0xd7 @(ABT_MODE | PSR_I_BIT | PSR_F_BIT)\n"
+	"stmia	r0!, {r2, r13 - r14}\n"
+	"mrs	r2, spsr\n"
+	"msr	cpsr_c, #0xdb @(UND_MODE | PSR_I_BIT | PSR_F_BIT)\n"
+	"stmia	r0!, {r2, r13 - r14}\n"
+	"mrs	r2, spsr\n"
+	"msr	cpsr_c, #0xd2 @(IRQ_MODE | PSR_I_BIT | PSR_F_BIT)\n"
+	"stmia	r0!, {r2, r13 - r14}\n"
+	"mrs	r2, spsr\n"
+	"msr	cpsr_c, #0xd1 @(FIQ_MODE | PSR_I_BIT | PSR_F_BIT)\n"
+	"stmia	r0!, {r2, r8 - r14}\n"
+#endif
+	"mrs	r2, spsr\n"
+	"stmia	r0!, {r2}\n"
+	"msr	cpsr_c, r1\n"
+	"bx	lr\n");
+}
+
+
+void fiq_debugger_dump_allregs(struct fiq_debugger_output *output,
+		const struct pt_regs *regs)
+{
+	struct mode_regs mode_regs;
+	unsigned long mode = regs->ARM_cpsr & MODE_MASK;
+
+	fiq_debugger_dump_regs(output, regs);
+	get_mode_regs(&mode_regs);
+
+	output->printf(output,
+			"%csvc: sp %08x  lr %08x  spsr %08x\n",
+			mode == SVC_MODE ? '*' : ' ',
+			mode_regs.sp_svc, mode_regs.lr_svc, mode_regs.spsr_svc);
+	output->printf(output,
+			"%cabt: sp %08x  lr %08x  spsr %08x\n",
+			mode == ABT_MODE ? '*' : ' ',
+			mode_regs.sp_abt, mode_regs.lr_abt, mode_regs.spsr_abt);
+	output->printf(output,
+			"%cund: sp %08x  lr %08x  spsr %08x\n",
+			mode == UND_MODE ? '*' : ' ',
+			mode_regs.sp_und, mode_regs.lr_und, mode_regs.spsr_und);
+	output->printf(output,
+			"%cirq: sp %08x  lr %08x  spsr %08x\n",
+			mode == IRQ_MODE ? '*' : ' ',
+			mode_regs.sp_irq, mode_regs.lr_irq, mode_regs.spsr_irq);
+	output->printf(output,
+			"%cfiq: r8 %08x  r9 %08x  r10 %08x  r11 %08x  r12 %08x\n",
+			mode == FIQ_MODE ? '*' : ' ',
+			mode_regs.r8_fiq, mode_regs.r9_fiq, mode_regs.r10_fiq,
+			mode_regs.r11_fiq, mode_regs.r12_fiq);
+	output->printf(output,
+			" fiq: sp %08x  lr %08x  spsr %08x\n",
+			mode_regs.sp_fiq, mode_regs.lr_fiq, mode_regs.spsr_fiq);
+}
+
+struct stacktrace_state {
+	struct fiq_debugger_output *output;
+	unsigned int depth;
+};
+
+static int report_trace(struct stackframe *frame, void *d)
+{
+	struct stacktrace_state *sts = d;
+
+	if (sts->depth) {
+		sts->output->printf(sts->output,
+			"  pc: %px (%pS), lr %px (%pS), sp %px, fp %px\n",
+			frame->pc, frame->pc, frame->lr, frame->lr,
+			frame->sp, frame->fp);
+		sts->depth--;
+		return 0;
+	}
+	sts->output->printf(sts->output, "  ...\n");
+
+	return sts->depth == 0;
+}
+
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+struct frame_tail {
+	struct frame_tail *fp;
+	unsigned long sp;
+	unsigned long lr;
+} __attribute__((packed));
+
+static struct frame_tail *user_backtrace(struct fiq_debugger_output *output,
+					struct frame_tail *tail)
+{
+	struct frame_tail buftail[2];
+
+	/* Also check accessibility of one struct frame_tail beyond */
+	if (!access_ok(tail, sizeof(buftail))) {
+		output->printf(output, "  invalid frame pointer %px\n",
+				tail);
+		return NULL;
+	}
+	if (__copy_from_user_inatomic(buftail, tail, sizeof(buftail))) {
+		output->printf(output,
+			"  failed to copy frame pointer %px\n", tail);
+		return NULL;
+	}
+
+	output->printf(output, "  %px\n", buftail[0].lr);
+
+	/* frame pointers should strictly progress back up the stack
+	 * (towards higher addresses) */
+	if (tail >= buftail[0].fp)
+		return NULL;
+
+	return buftail[0].fp-1;
+}
+
+void fiq_debugger_dump_stacktrace(struct fiq_debugger_output *output,
+		const struct pt_regs *regs, unsigned int depth, void *ssp)
+{
+	struct frame_tail *tail;
+#ifdef THREAD_INFO
+	struct thread_info *real_thread_info = THREAD_INFO(ssp);
+#endif
+	struct stacktrace_state sts;
+
+	sts.depth = depth;
+	sts.output = output;
+#ifdef THREAD_INFO
+	*current_thread_info() = *real_thread_info;
+#endif
+
+	if (!current)
+		output->printf(output, "current NULL\n");
+	else
+		output->printf(output, "pid: %d  comm: %s\n",
+			current->pid, current->comm);
+	fiq_debugger_dump_regs(output, regs);
+
+	if (!user_mode(regs)) {
+		struct stackframe frame;
+		frame.fp = regs->ARM_fp;
+		frame.sp = regs->ARM_sp;
+		frame.lr = regs->ARM_lr;
+		frame.pc = regs->ARM_pc;
+		output->printf(output, "\n");
+		walk_stackframe(&frame, report_trace, &sts);
+		return;
+	}
+
+	tail = ((struct frame_tail *) regs->ARM_fp) - 1;
+	while (depth-- && tail && !((unsigned long) tail & 3))
+		tail = user_backtrace(output, tail);
+}
+#endif

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/fiq_debugger_arm64.c
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ * Author: Colin Cross <ccross@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/ptrace.h>
+#include <linux/version.h>
+#include <asm/stacktrace.h>
+
+#include "fiq_debugger_priv.h"
+
+static char *mode_name(const struct pt_regs *regs)
+{
+	if (compat_user_mode(regs)) {
+		return "USR";
+	} else {
+		switch (processor_mode(regs)) {
+		case PSR_MODE_EL0t: return "EL0t";
+		case PSR_MODE_EL1t: return "EL1t";
+		case PSR_MODE_EL1h: return "EL1h";
+		case PSR_MODE_EL2t: return "EL2t";
+		case PSR_MODE_EL2h: return "EL2h";
+		default: return "???";
+		}
+	}
+}
+
+void fiq_debugger_dump_pc(struct fiq_debugger_output *output,
+		const struct pt_regs *regs)
+{
+	output->printf(output, " pc %016lx cpsr %08lx mode %s\n",
+		regs->pc, regs->pstate, mode_name(regs));
+}
+
+void fiq_debugger_dump_regs_aarch32(struct fiq_debugger_output *output,
+		const struct pt_regs *regs)
+{
+	output->printf(output, " r0 %08x  r1 %08x  r2 %08x  r3 %08x\n",
+			regs->compat_usr(0), regs->compat_usr(1),
+			regs->compat_usr(2), regs->compat_usr(3));
+	output->printf(output, " r4 %08x  r5 %08x  r6 %08x  r7 %08x\n",
+			regs->compat_usr(4), regs->compat_usr(5),
+			regs->compat_usr(6), regs->compat_usr(7));
+	output->printf(output, " r8 %08x  r9 %08x r10 %08x r11 %08x\n",
+			regs->compat_usr(8), regs->compat_usr(9),
+			regs->compat_usr(10), regs->compat_usr(11));
+	output->printf(output, " ip %08x  sp %08x  lr %08x  pc %08x\n",
+			regs->compat_usr(12), regs->compat_sp,
+			regs->compat_lr, regs->pc);
+	output->printf(output, " cpsr %08x (%s)\n",
+			regs->pstate, mode_name(regs));
+}
+
+void fiq_debugger_dump_regs_aarch64(struct fiq_debugger_output *output,
+		const struct pt_regs *regs)
+{
+
+	output->printf(output, "  x0 %016lx   x1 %016lx\n",
+			regs->regs[0], regs->regs[1]);
+	output->printf(output, "  x2 %016lx   x3 %016lx\n",
+			regs->regs[2], regs->regs[3]);
+	output->printf(output, "  x4 %016lx   x5 %016lx\n",
+			regs->regs[4], regs->regs[5]);
+	output->printf(output, "  x6 %016lx   x7 %016lx\n",
+			regs->regs[6], regs->regs[7]);
+	output->printf(output, "  x8 %016lx   x9 %016lx\n",
+			regs->regs[8], regs->regs[9]);
+	output->printf(output, " x10 %016lx  x11 %016lx\n",
+			regs->regs[10], regs->regs[11]);
+	output->printf(output, " x12 %016lx  x13 %016lx\n",
+			regs->regs[12], regs->regs[13]);
+	output->printf(output, " x14 %016lx  x15 %016lx\n",
+			regs->regs[14], regs->regs[15]);
+	output->printf(output, " x16 %016lx  x17 %016lx\n",
+			regs->regs[16], regs->regs[17]);
+	output->printf(output, " x18 %016lx  x19 %016lx\n",
+			regs->regs[18], regs->regs[19]);
+	output->printf(output, " x20 %016lx  x21 %016lx\n",
+			regs->regs[20], regs->regs[21]);
+	output->printf(output, " x22 %016lx  x23 %016lx\n",
+			regs->regs[22], regs->regs[23]);
+	output->printf(output, " x24 %016lx  x25 %016lx\n",
+			regs->regs[24], regs->regs[25]);
+	output->printf(output, " x26 %016lx  x27 %016lx\n",
+			regs->regs[26], regs->regs[27]);
+	output->printf(output, " x28 %016lx  x29 %016lx\n",
+			regs->regs[28], regs->regs[29]);
+	output->printf(output, " x30 %016lx   sp %016lx\n",
+			regs->regs[30], regs->sp);
+	output->printf(output, "  pc %016lx cpsr %08x (%s)\n",
+			regs->pc, regs->pstate, mode_name(regs));
+}
+
+void fiq_debugger_dump_regs(struct fiq_debugger_output *output,
+		const struct pt_regs *regs)
+{
+	if (compat_user_mode(regs))
+		fiq_debugger_dump_regs_aarch32(output, regs);
+	else
+		fiq_debugger_dump_regs_aarch64(output, regs);
+}
+
+#define READ_SPECIAL_REG(x) ({ \
+	u64 val; \
+	asm volatile ("mrs %0, " # x : "=r"(val)); \
+	val; \
+})
+
+void fiq_debugger_dump_allregs(struct fiq_debugger_output *output,
+		const struct pt_regs *regs)
+{
+	u32 pstate = READ_SPECIAL_REG(CurrentEl);
+	bool in_el2 = (pstate & PSR_MODE_MASK) >= PSR_MODE_EL2t;
+
+	fiq_debugger_dump_regs(output, regs);
+
+	output->printf(output, " sp_el0   %016lx\n",
+			READ_SPECIAL_REG(sp_el0));
+
+	if (in_el2)
+		output->printf(output, " sp_el1   %016lx\n",
+				READ_SPECIAL_REG(sp_el1));
+
+	output->printf(output, " elr_el1  %016lx\n",
+			READ_SPECIAL_REG(elr_el1));
+
+	output->printf(output, " spsr_el1 %08lx\n",
+			READ_SPECIAL_REG(spsr_el1));
+
+	if (in_el2) {
+		output->printf(output, " spsr_irq %08lx\n",
+				READ_SPECIAL_REG(spsr_irq));
+		output->printf(output, " spsr_abt %08lx\n",
+				READ_SPECIAL_REG(spsr_abt));
+		output->printf(output, " spsr_und %08lx\n",
+				READ_SPECIAL_REG(spsr_und));
+		output->printf(output, " spsr_fiq %08lx\n",
+				READ_SPECIAL_REG(spsr_fiq));
+		output->printf(output, " elr_el2 %08lx\n",
+				READ_SPECIAL_REG(elr_el2));
+		output->printf(output, " spsr_el2 %08lx\n",
+				READ_SPECIAL_REG(spsr_el2));
+	}
+}
+
+#ifndef CONFIG_FIQ_DEBUGGER_MODULE
+struct stacktrace_state {
+	struct fiq_debugger_output *output;
+	unsigned int depth;
+};
+
+static bool report_trace(void *data, unsigned long pc)
+{
+	struct stacktrace_state *sts = data;
+
+	if (sts->depth) {
+		sts->output->printf(sts->output, "[<%016lx>] %pS:\n", pc, pc);
+		sts->depth--;
+		return true;
+	}
+	sts->output->printf(sts->output, "  ...\n");
+
+	return sts->depth != 0;
+}
+
+void fiq_debugger_dump_stacktrace(struct fiq_debugger_output *output,
+		const struct pt_regs *regs, unsigned int depth, void *ssp)
+{
+	struct stacktrace_state sts;
+
+	sts.depth = depth;
+	sts.output = output;
+
+	if (!current)
+		output->printf(output, "current NULL\n");
+	else
+		output->printf(output, "pid: %d  comm: %s\n",
+			current->pid, current->comm);
+	fiq_debugger_dump_regs(output, regs);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0)
+	if (!user_mode(regs)) {
+		struct stackframe frame;
+		frame.fp = regs->regs[29];
+		frame.pc = regs->pc;
+		frame.prev_type = STACK_TYPE_UNKNOWN;
+		output->printf(output, "\n");
+		walk_stackframe(current, &frame, report_trace, &sts);
+	}
+#else
+	if (!user_mode(regs)) {
+		output->printf(output, "\n");
+		arch_stack_walk(report_trace, (void *)&sts, current, (struct pt_regs *)regs);
+	}
+#endif
+}
+#endif

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/fiq_debugger_priv.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ * Author: Colin Cross <ccross@android.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _FIQ_DEBUGGER_PRIV_H_
+#define _FIQ_DEBUGGER_PRIV_H_
+
+#ifndef CONFIG_THREAD_INFO_IN_TASK
+#define THREAD_INFO(sp) ((struct thread_info *) \
+		((unsigned long)(sp) & ~(THREAD_SIZE - 1)))
+#endif
+
+struct fiq_debugger_output {
+	void (*printf)(struct fiq_debugger_output *output, const char *fmt, ...);
+};
+
+struct pt_regs;
+
+void fiq_debugger_dump_pc(struct fiq_debugger_output *output,
+		const struct pt_regs *regs);
+void fiq_debugger_dump_regs(struct fiq_debugger_output *output,
+		const struct pt_regs *regs);
+void fiq_debugger_dump_allregs(struct fiq_debugger_output *output,
+		const struct pt_regs *regs);
+void fiq_debugger_dump_stacktrace(struct fiq_debugger_output *output,
+		const struct pt_regs *regs, unsigned int depth, void *ssp);
+
+#endif

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/fiq_debugger_ringbuf.h
@@ -0,0 +1,94 @@
+/*
+ * drivers/staging/android/fiq_debugger/fiq_debugger_ringbuf.h
+ *
+ * simple lockless ringbuffer
+ *
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+struct fiq_debugger_ringbuf {
+	int len;
+	int head;
+	int tail;
+	u8 buf[];
+};
+
+
+static inline struct fiq_debugger_ringbuf *fiq_debugger_ringbuf_alloc(int len)
+{
+	struct fiq_debugger_ringbuf *rbuf;
+
+	rbuf = kzalloc(sizeof(*rbuf) + len, GFP_KERNEL);
+	if (rbuf == NULL)
+		return NULL;
+
+	rbuf->len = len;
+	rbuf->head = 0;
+	rbuf->tail = 0;
+	smp_mb();
+
+	return rbuf;
+}
+
+static inline void fiq_debugger_ringbuf_free(struct fiq_debugger_ringbuf *rbuf)
+{
+	kfree(rbuf);
+}
+
+static inline int fiq_debugger_ringbuf_level(struct fiq_debugger_ringbuf *rbuf)
+{
+	int level = rbuf->head - rbuf->tail;
+
+	if (level < 0)
+		level = rbuf->len + level;
+
+	return level;
+}
+
+static inline int fiq_debugger_ringbuf_room(struct fiq_debugger_ringbuf *rbuf)
+{
+	return rbuf->len - fiq_debugger_ringbuf_level(rbuf) - 1;
+}
+
+static inline u8
+fiq_debugger_ringbuf_peek(struct fiq_debugger_ringbuf *rbuf, int i)
+{
+	return rbuf->buf[(rbuf->tail + i) % rbuf->len];
+}
+
+static inline int
+fiq_debugger_ringbuf_consume(struct fiq_debugger_ringbuf *rbuf, int count)
+{
+	count = min(count, fiq_debugger_ringbuf_level(rbuf));
+
+	rbuf->tail = (rbuf->tail + count) % rbuf->len;
+	smp_mb();
+
+	return count;
+}
+
+static inline int
+fiq_debugger_ringbuf_push(struct fiq_debugger_ringbuf *rbuf, u8 datum)
+{
+	if (fiq_debugger_ringbuf_room(rbuf) == 0)
+		return 0;
+
+	rbuf->buf[rbuf->head] = datum;
+	smp_mb();
+	rbuf->head = (rbuf->head + 1) % rbuf->len;
+	smp_mb();
+
+	return 1;
+}

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/fiq_watchdog.c
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/pstore_ram.h>
+
+#include "fiq_watchdog.h"
+#include "fiq_debugger_priv.h"
+
+static DEFINE_RAW_SPINLOCK(fiq_watchdog_lock);
+
+static void fiq_watchdog_printf(struct fiq_debugger_output *output,
+				const char *fmt, ...)
+{
+	char buf[256];
+	va_list ap;
+	int len;
+
+	va_start(ap, fmt);
+	len = vscnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+
+	ramoops_console_write_buf(buf, len);
+}
+
+struct fiq_debugger_output fiq_watchdog_output = {
+	.printf = fiq_watchdog_printf,
+};
+
+void fiq_watchdog_triggered(const struct pt_regs *regs, void *svc_sp)
+{
+	char msg[24];
+	int len;
+
+	raw_spin_lock(&fiq_watchdog_lock);
+
+	len = scnprintf(msg, sizeof(msg), "watchdog fiq cpu %d\n",
+			THREAD_INFO(svc_sp)->cpu);
+	ramoops_console_write_buf(msg, len);
+
+	fiq_debugger_dump_stacktrace(&fiq_watchdog_output, regs, 100, svc_sp);
+
+	raw_spin_unlock(&fiq_watchdog_lock);
+}

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/fiq_watchdog.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _FIQ_WATCHDOG_H_
+#define _FIQ_WATCHDOG_H_
+
+void fiq_watchdog_triggered(const struct pt_regs *regs, void *svc_sp);
+
+#endif

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/rk_fiq_debugger.c
@@ -0,0 +1,1166 @@
+/*
+ * drivers/soc/rockchip/rk_fiq_debugger.c
+ *
+ * Serial Debugger Interface for Rockchip
+ *
+ * Copyright (C) 2012 Rockchip Electronics Co., Ltd.
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/stdarg.h>
+#include <linux/cpu.h>
+#include <linux/cpu_pm.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/serial_reg.h>
+#include <linux/slab.h>
+#include <linux/stacktrace.h>
+#include <linux/uaccess.h>
+#include <linux/kfifo.h>
+#include <linux/kthread.h>
+#include <linux/sched/rt.h>
+#include "fiq_debugger.h"
+#include <linux/irqchip/arm-gic.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include "rk_fiq_debugger.h"
+#include <linux/console.h>
+
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+#include <linux/rockchip/rockchip_sip.h>
+#endif
+#define UART_USR			0x1f /* In: UART Status Register */
+#define UART_USR_RX_FIFO_FULL		0x10 /* Receive FIFO full */
+#define UART_USR_RX_FIFO_NOT_EMPTY	0x08 /* Receive FIFO not empty */
+#define UART_USR_TX_FIFO_EMPTY		0x04 /* Transmit FIFO empty */
+#define UART_USR_TX_FIFO_NOT_FULL	0x02 /* Transmit FIFO not full */
+#define UART_USR_BUSY			0x01 /* UART busy indicator */
+#define UART_SRR			0x22 /* software reset register */
+#define RK_UART_RFL			0x21 /* UART Receive Fifo Level Register */
+
+struct rk_fiq_debugger {
+	int irq;
+	int baudrate;
+	struct fiq_debugger_pdata pdata;
+	void __iomem *debug_port_base;
+	bool break_seen;
+#ifdef CONFIG_RK_CONSOLE_THREAD
+	struct task_struct *console_task;
+#endif
+};
+
+static int rk_fiq_debugger_id;
+static int serial_hwirq;
+
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+static bool tf_fiq_sup;
+#endif
+
+static inline void rk_fiq_write(struct rk_fiq_debugger *t,
+	unsigned int val, unsigned int off)
+{
+	__raw_writel(val, t->debug_port_base + off * 4);
+}
+
+static inline unsigned int rk_fiq_read(struct rk_fiq_debugger *t,
+	unsigned int off)
+{
+	return __raw_readl(t->debug_port_base + off * 4);
+}
+
+static inline unsigned int rk_fiq_read_lsr(struct rk_fiq_debugger *t)
+{
+	unsigned int lsr;
+
+	lsr = rk_fiq_read(t, UART_LSR);
+	if (lsr & UART_LSR_BI)
+		t->break_seen = true;
+
+	return lsr;
+}
+
+static int debug_port_init(struct platform_device *pdev)
+{
+	int dll = 0, dlm = 0;
+	struct rk_fiq_debugger *t;
+
+	console_lock();
+
+	t = container_of(dev_get_platdata(&pdev->dev), typeof(*t), pdata);
+
+	if (rk_fiq_read(t, UART_LSR) & UART_LSR_DR)
+		(void)rk_fiq_read(t, UART_RX);
+
+	switch (t->baudrate) {
+	case 1500000:
+		dll = 0x1;
+		break;
+	case 115200:
+	default:
+		dll = 0xd;
+		break;
+	}
+	/* reset uart */
+	rk_fiq_write(t, 0x07, UART_SRR);
+	udelay(10);
+	/* set uart to loop back mode */
+	rk_fiq_write(t, 0x10, UART_MCR);
+
+	rk_fiq_write(t, 0x83, UART_LCR);
+	/* set baud rate */
+	rk_fiq_write(t, dll, UART_DLL);
+	rk_fiq_write(t, dlm, UART_DLM);
+	rk_fiq_write(t, 0x03, UART_LCR);
+
+	/* enable rx interrupt */
+	rk_fiq_write(t, UART_IER_RDI, UART_IER);
+
+	/*
+	 * Interrupt on every character when received, but we can enable fifo for TX
+	 * I found that if we enable the RX fifo, some problem may vanish such as when
+	 * you continuously input characters in the command line the uart irq may be disable
+	 * because of the uart irq is served when CPU is at IRQ exception, but it is
+	 * found unregistered, so it is disable.
+	 */
+	rk_fiq_write(t, 0x01, UART_FCR);
+
+	/* disbale loop back mode */
+	rk_fiq_write(t, 0x0, UART_MCR);
+
+	console_unlock();
+
+	return 0;
+}
+
+static int debug_getc(struct platform_device *pdev)
+{
+	unsigned int lsr, usr, rfl, iir;
+	struct rk_fiq_debugger *t;
+	unsigned int temp;
+	static unsigned int n;
+	static char buf[32];
+
+	t = container_of(dev_get_platdata(&pdev->dev), typeof(*t), pdata);
+	/*
+	 * Clear uart interrupt status
+	 */
+	iir = rk_fiq_read(t, UART_IIR);
+	usr = rk_fiq_read(t, UART_USR);
+	lsr = rk_fiq_read_lsr(t);
+
+	/*
+	 * There are ways to get Designware-based UARTs into a state where
+	 * they are asserting UART_IIR_RX_TIMEOUT but there is no actual
+	 * data available.  If we see such a case then we'll do a bogus
+	 * read.  If we don't do this then the "RX TIMEOUT" interrupt will
+	 * fire forever.
+	 */
+	if ((iir & 0x3f) == UART_IIR_RX_TIMEOUT) {
+		rfl = rk_fiq_read(t, RK_UART_RFL);
+		if (!(lsr & (UART_LSR_DR | UART_LSR_BI)) && !(usr & 0x1) && (rfl == 0))
+			rk_fiq_read(t, UART_RX);
+	}
+
+	if (lsr & UART_LSR_DR) {
+		temp = rk_fiq_read(t, UART_RX);
+		buf[++n & 0x1f] = temp;
+
+		if (temp == 'q') {
+			if ((buf[(n - 1) & 0x1f] == 'i') &&
+			    (buf[(n - 2) & 0x1f] == 'f') &&
+			    (buf[(n - 3) & 0x1f] != '_') &&
+			    (buf[(n - 3) & 0x1f] != ' '))
+				return FIQ_DEBUGGER_BREAK;
+			else
+				return temp;
+		} else {
+			return temp;
+		}
+	}
+
+	return FIQ_DEBUGGER_NO_CHAR;
+}
+
+static void debug_putc(struct platform_device *pdev, unsigned int c)
+{
+	struct rk_fiq_debugger *t;
+	unsigned int count = 10000;
+
+	t = container_of(dev_get_platdata(&pdev->dev), typeof(*t), pdata);
+
+	while (!(rk_fiq_read(t, UART_USR) & UART_USR_TX_FIFO_NOT_FULL) && count--)
+		udelay(10);
+
+	rk_fiq_write(t, c, UART_TX);
+}
+
+static int debug_getc_dummy(struct platform_device *pdev)
+{
+	return FIQ_DEBUGGER_NO_CHAR;
+}
+
+static void debug_putc_dummy(struct platform_device *pdev, unsigned int c)
+{
+}
+
+static void debug_flush(struct platform_device *pdev)
+{
+	struct rk_fiq_debugger *t;
+	unsigned int count = 10000;
+	t = container_of(dev_get_platdata(&pdev->dev), typeof(*t), pdata);
+
+	while (!(rk_fiq_read_lsr(t) & UART_LSR_TEMT) && count--)
+		udelay(10);
+}
+
+#ifdef CONFIG_RK_CONSOLE_THREAD
+#define FIFO_SIZE SZ_64K
+#define TTY_FIFO_SIZE SZ_64K
+static struct kfifo fifo;
+static struct kfifo tty_fifo;
+static bool console_thread_stop; /* write on console_write */
+static bool console_thread_running; /* write on console_thread */
+static unsigned int console_dropped_messages;
+
+static int write_room(struct platform_device *pdev)
+{
+	return (TTY_FIFO_SIZE - kfifo_len(&tty_fifo));
+}
+
+#define console_poll(cond, count, us) \
+do { \
+	if (!IS_ENABLED(CONFIG_HIGH_RES_TIMERS) && CONFIG_HZ < 1000 && us < 1000) { \
+		if (!(cond)) { \
+			ktime_t timeout = ktime_add_us(ktime_get(), us * count); \
+			int oldnice = task_nice(current); \
+			if (!(cond)) { \
+				set_user_nice(current, MAX_NICE); \
+				while (!(cond)) { \
+					if (ktime_compare(ktime_get(), timeout) > 0) \
+						break; \
+					schedule(); \
+				} \
+				set_user_nice(current, oldnice); \
+			} \
+		} \
+	} else { \
+		while (!(cond) && count--) \
+			usleep_range(us, us + us / 20); \
+	} \
+} while (0)
+
+static void console_putc(struct platform_device *pdev, unsigned int c)
+{
+	struct rk_fiq_debugger *t;
+	unsigned int count = 2;		/* loop 2 times is enough */
+	unsigned long us = 400;		/* the time to send 60 byte for baudrate 1500000 */
+
+	t = container_of(dev_get_platdata(&pdev->dev), typeof(*t), pdata);
+
+	if (t->baudrate == 115200)
+		us = 5160;	/* the time to send 60 byte for baudrate 115200 */
+
+	console_poll(rk_fiq_read(t, UART_USR) & UART_USR_TX_FIFO_NOT_FULL, count, us);
+
+	rk_fiq_write(t, c, UART_TX);
+}
+
+static void console_flush(struct platform_device *pdev)
+{
+	struct rk_fiq_debugger *t;
+	unsigned int count = 2;		/* loop 2 times is enough */
+	unsigned long us = 428;		/* the time to send 64 byte for baudrate 1500000 */
+
+	t = container_of(dev_get_platdata(&pdev->dev), typeof(*t), pdata);
+
+	if (t->baudrate == 115200)
+		us = 5500;	/* the time to send 64 byte for baudrate 115200 */
+
+	while (!(rk_fiq_read_lsr(t) & UART_LSR_TEMT) && count--)
+		usleep_range(us, us + us / 20);
+}
+
+static void console_put(struct platform_device *pdev,
+			const char *s, unsigned int count)
+{
+	while (count--) {
+		if (*s == '\n')
+			console_putc(pdev, '\r');
+		console_putc(pdev, *s++);
+	}
+}
+
+static void debug_put(struct platform_device *pdev,
+		      const char *s, unsigned int count)
+{
+	while (count--) {
+		if (*s == '\n')
+			debug_putc(pdev, '\r');
+		debug_putc(pdev, *s++);
+	}
+}
+
+static void wake_up_console_thread(struct task_struct *console_task)
+{
+	/*
+	 * Avoid dead lock on console_task->pi_lock and console_lock
+	 * when call printk() in try_to_wake_up().
+	 *
+	 * cpu0 hold console_lock, then try lock pi_lock fail:
+	 *   printk()->vprintk_emit()->console_unlock()->try_to_wake_up()
+	 *   ->lock(pi_lock)->deadlock
+	 *
+	 * cpu1 hold pi_lock, then try lock console_lock fail:
+	 *   console_thread()->console_put()->usleep_range()->run_hrtimer()
+	 *   ->hrtimer_wakeup()->try_to_wake_up()[hold_pi_lock]->printk()
+	 *   ->vprintk_emit()->console_trylock_spining()->cpu_relax()->deadlock
+	 *
+	 * if cpu0 does not hold console_lock, cpu1 also deadlock on pi_lock:
+	 *   ...->hrtimer_wakeup()->try_to_wake_up()[hold_pi_lock]->printk()
+	 *   ->vprintk_emit()->console_unlock()->try_to_wake_up()
+	 *   ->lock(pi_lock)->deadlock
+	 *
+	 * so when console_task is running on usleep_range(), printk()
+	 * should not wakeup console_task to avoid lock(pi_lock) again,
+	 * as run_hrtimer() will wakeup console_task later.
+	 * console_thread_running==false guarantee that console_task
+	 * is not running on usleep_range().
+	 */
+	if (!READ_ONCE(console_thread_running))
+		wake_up_process(console_task);
+}
+
+static int console_thread(void *data)
+{
+	struct platform_device *pdev = data;
+	char buf[64], c = 0;
+	unsigned int len = 0, len_tty = 0;
+
+	while (1) {
+		unsigned int dropped;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (console_thread_stop || (kfifo_is_empty(&fifo) && kfifo_is_empty(&tty_fifo))) {
+			smp_store_mb(console_thread_running, false);
+			schedule();
+			smp_store_mb(console_thread_running, true);
+		}
+		if (kthread_should_stop())
+			break;
+		set_current_state(TASK_RUNNING);
+
+		while (!console_thread_stop && (!kfifo_is_empty(&fifo) || !kfifo_is_empty(&tty_fifo))) {
+			while (!console_thread_stop && kfifo_get(&fifo, &c)) {
+				console_put(pdev, &c, 1);
+				if (c == '\n')
+					break;
+			}
+
+			while (!console_thread_stop && kfifo_get(&tty_fifo, &c)) {
+				console_putc(pdev, c);
+				len_tty++;
+				if (c == '\n')
+					break;
+			}
+		}
+
+		if (len_tty > 0)
+			fiq_tty_wake_up(pdev);
+		len_tty = 0;
+
+		dropped = console_dropped_messages;
+		if (dropped && !console_thread_stop) {
+			console_dropped_messages = 0;
+			smp_wmb();
+			len = sprintf(buf, "** %u console messages dropped **\n",
+				       dropped);
+			console_put(pdev, buf, len);
+		}
+		if (!console_thread_stop)
+			console_flush(pdev);
+	}
+
+	return 0;
+}
+
+static void console_write(struct platform_device *pdev, const char *s, unsigned int count)
+{
+	unsigned int fifo_count = FIFO_SIZE;
+	unsigned char c;
+	struct rk_fiq_debugger *t;
+
+	t = container_of(dev_get_platdata(&pdev->dev), typeof(*t), pdata);
+
+	if (console_thread_stop ||
+	    oops_in_progress ||
+	    system_state == SYSTEM_HALT ||
+	    system_state == SYSTEM_POWER_OFF ||
+	    system_state == SYSTEM_RESTART) {
+		if (!console_thread_stop) {
+			console_thread_stop = true;
+			smp_wmb();
+			debug_flush(pdev);
+			while (fifo_count-- && kfifo_get(&fifo, &c))
+				debug_put(pdev, &c, 1);
+		}
+		debug_put(pdev, s, count);
+		debug_flush(pdev);
+	} else if (count) {
+		unsigned int ret = 0;
+
+		if (kfifo_len(&fifo) + count <= FIFO_SIZE)
+			ret = kfifo_in(&fifo, s, count);
+		if (!ret) {
+			console_dropped_messages++;
+			smp_wmb();
+		} else {
+			wake_up_console_thread(t->console_task);
+		}
+	}
+}
+
+static int tty_write(struct platform_device *pdev, const char *s, int count)
+{
+	unsigned int ret = 0;
+	struct rk_fiq_debugger *t;
+
+	if (console_thread_stop)
+		return count;
+	t = container_of(dev_get_platdata(&pdev->dev), typeof(*t), pdata);
+
+	if (count > 0) {
+		if (kfifo_len(&tty_fifo) + count <= TTY_FIFO_SIZE)
+			ret = kfifo_in(&tty_fifo, s, count);
+
+		if (ret <= 0)
+			return 0;
+		wake_up_console_thread(t->console_task);
+	}
+	return count;
+}
+#endif
+
+static void fiq_enable(struct platform_device *pdev, unsigned int irq, bool on)
+{
+	if (on)
+		enable_irq(irq);
+	else
+		disable_irq(irq);
+}
+
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+#ifdef CONFIG_ARM_SDE_INTERFACE
+#include <linux/arm_sdei.h>
+#include <asm/smp_plat.h>
+#include <linux/suspend.h>
+void fiq_debugger_fiq_get_(const char *fmt, ...);
+
+static struct rk_fiq_sdei_st {
+	u32 cur_cpu;
+	u32 sw_cpu;
+	u32 cpu_can_sw;
+	int fiq_en;
+	u32 event_id;
+	u32 cpu_off_sw;
+	u32 cpu_sw_event_id;
+} rk_fiq_sdei;
+
+int sdei_fiq_debugger_is_enabled(void)
+{
+	return rk_fiq_sdei.fiq_en;
+}
+
+static int fiq_sdei_event_callback(u32 event, struct pt_regs *regs, void *arg)
+{
+	int cpu_id = get_logical_index(read_cpuid_mpidr() &
+				       MPIDR_HWID_BITMASK);
+	fiq_debugger_fiq(regs, cpu_id);
+
+	return 0;
+}
+
+static void rk_fiq_sdei_event_sw_cpu(int wait_disable)
+{
+	unsigned long affinity;
+	int cnt = 100000;
+	int ret = 0;
+
+	do {
+		ret = sdei_event_disable_nolock(rk_fiq_sdei.event_id);
+		if (!ret)
+			break;
+		cnt--;
+		udelay(20);
+	} while (wait_disable && cnt);
+
+	affinity = cpu_logical_map(rk_fiq_sdei.sw_cpu) & MPIDR_HWID_BITMASK;
+	ret = sdei_event_routing_set_nolock(rk_fiq_sdei.event_id,
+					    SDEI_EVENT_REGISTER_RM_PE,
+					    affinity);
+	ret = sdei_event_enable_nolock(rk_fiq_sdei.event_id);
+	rk_fiq_sdei.cur_cpu = rk_fiq_sdei.sw_cpu;
+}
+
+static int fiq_sdei_sw_cpu_event_callback(u32 event, struct pt_regs *regs, void *arg)
+{
+	int cnt = 10000;
+	int ret = 0;
+	int cpu_id = event - rk_fiq_sdei.cpu_sw_event_id;
+
+	WARN_ON(cpu_id !=
+		get_logical_index(read_cpuid_mpidr() & MPIDR_HWID_BITMASK));
+
+	if (cpu_id == rk_fiq_sdei.sw_cpu) {
+		if (!rk_fiq_sdei.cpu_off_sw) {
+			rk_fiq_sdei.cpu_can_sw = 1;
+		} else {
+			rk_fiq_sdei_event_sw_cpu(1);
+			rk_fiq_sdei.cpu_off_sw = 0;
+		}
+	} else if (cpu_id == rk_fiq_sdei.cur_cpu && !rk_fiq_sdei.cpu_off_sw) {
+		while (!rk_fiq_sdei.cpu_can_sw && cnt) {
+			udelay(10);
+			cnt--;
+		};
+
+		if (rk_fiq_sdei.cpu_can_sw) {
+			rk_fiq_sdei_event_sw_cpu(0);
+			rk_fiq_sdei.cpu_can_sw = 0;
+		}
+	}
+	return ret;
+}
+
+static void _rk_fiq_dbg_sdei_switch_cpu(unsigned int cpu, int cpu_off)
+{
+	if (cpu == rk_fiq_sdei.cur_cpu)
+		return;
+	rk_fiq_sdei.sw_cpu = cpu;
+	rk_fiq_sdei.cpu_can_sw = 0;
+	rk_fiq_sdei.cpu_off_sw = cpu_off;
+	sip_fiq_debugger_sdei_switch_cpu(rk_fiq_sdei.cur_cpu, cpu, cpu_off);
+}
+
+static void rk_fiq_dbg_sdei_switch_cpu(struct platform_device *pdev,
+				       unsigned int cpu)
+{
+	_rk_fiq_dbg_sdei_switch_cpu(cpu, 0);
+}
+
+static int fiq_dbg_sdei_cpu_off_migrate_fiq(unsigned int cpu)
+{
+	unsigned int target_cpu;
+	int cnt = 10000;
+
+	if (rk_fiq_sdei.cur_cpu == cpu) {
+		target_cpu = cpumask_any_but(cpu_online_mask, cpu);
+		_rk_fiq_dbg_sdei_switch_cpu(target_cpu, 1);
+
+		while (rk_fiq_sdei.cur_cpu == cpu && cnt) {
+			udelay(10);
+			cnt--;
+		};
+		if (!cnt)
+			pr_err("%s: from %d to %d err!\n",
+			       __func__, cpu, target_cpu);
+	}
+
+	return 0;
+}
+
+static int fiq_dbg_sdei_pm_callback(struct notifier_block *nb,
+				    unsigned long mode, void *_unused)
+{
+	unsigned int target_cpu;
+
+	switch (mode) {
+	case PM_SUSPEND_PREPARE:
+		target_cpu = cpumask_first(cpu_online_mask);
+		if (target_cpu != 0)
+			pr_err("%s: fiq for core !\n", __func__);
+		else
+			_rk_fiq_dbg_sdei_switch_cpu(target_cpu, 1);
+		break;
+	default:
+	break;
+	}
+	return 0;
+}
+
+static struct notifier_block fiq_dbg_sdei_pm_nb = {
+	.notifier_call = fiq_dbg_sdei_pm_callback,
+};
+
+static int fiq_debugger_sdei_enable(struct rk_fiq_debugger *t)
+{
+	int ret, cpu, i;
+	int is_dyn_event = false;
+
+	ret = sip_fiq_debugger_sdei_get_event_id(&rk_fiq_sdei.event_id,
+						 &rk_fiq_sdei.cpu_sw_event_id,
+						 NULL);
+
+	if (ret) {
+		pr_err("%s: get event id error!\n", __func__);
+		return ret;
+	}
+
+	/* If we can't get a valid fiq event, use dynamic event instead */
+	if (rk_fiq_sdei.event_id == 0) {
+		ret = sdei_interrupt_bind(serial_hwirq, &rk_fiq_sdei.event_id);
+		if (ret) {
+			pr_err("%s: bind intr:%d error!\n", __func__, serial_hwirq);
+			return ret;
+		}
+
+		is_dyn_event = true;
+	}
+
+	ret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
+					"soc/rk_sdei_fiq_debugger",
+					NULL,
+					fiq_dbg_sdei_cpu_off_migrate_fiq);
+	if (ret < 0) {
+		pr_err("%s: cpuhp_setup_state_nocalls error! %d\n",
+		       __func__, ret);
+		return ret;
+	}
+
+	if (register_pm_notifier(&fiq_dbg_sdei_pm_nb)) {
+		pr_err("%s: register pm notify error: %d!\n", __func__, ret);
+		return ret;
+	}
+
+	ret = sdei_event_register(rk_fiq_sdei.event_id,
+				  fiq_sdei_event_callback, NULL);
+
+	if (ret) {
+		pr_err("%s: sdei_event_register error!\n", __func__);
+		unregister_pm_notifier(&fiq_dbg_sdei_pm_nb);
+		return ret;
+	}
+
+	rk_fiq_sdei.cur_cpu = 0;
+
+	ret = sdei_event_routing_set(rk_fiq_sdei.event_id,
+				     SDEI_EVENT_REGISTER_RM_PE,
+				     cpu_logical_map(rk_fiq_sdei.cur_cpu));
+
+	if (ret) {
+		pr_err("%s: sdei_event_routing_set error!\n", __func__);
+		goto err;
+	}
+
+	ret = sdei_event_enable(rk_fiq_sdei.event_id);
+	if (ret) {
+		pr_err("%s: sdei_event_enable error!\n", __func__);
+		goto err;
+	}
+
+	for (cpu = 0; cpu < num_possible_cpus(); cpu++) {
+		ret = sdei_event_register(rk_fiq_sdei.cpu_sw_event_id + cpu,
+					  fiq_sdei_sw_cpu_event_callback,
+					  NULL);
+		if (ret) {
+			pr_err("%s: cpu %d sdei_event_register error!\n",
+			       __func__, cpu);
+			goto cpu_sw_err;
+		}
+		ret = sdei_event_routing_set(rk_fiq_sdei.cpu_sw_event_id + cpu,
+					     SDEI_EVENT_REGISTER_RM_PE,
+					     cpu_logical_map(cpu));
+
+		if (ret) {
+			pr_err("%s:cpu %d fiq_sdei_event_routing_set error!\n",
+			       __func__, cpu);
+			goto cpu_sw_err;
+		}
+
+		ret = sdei_event_enable(rk_fiq_sdei.cpu_sw_event_id + cpu);
+		if (ret) {
+			pr_err("%s: cpu %d sdei_event_enable error!\n",
+			       __func__, cpu);
+			goto cpu_sw_err;
+		}
+	}
+
+	t->pdata.switch_cpu = rk_fiq_dbg_sdei_switch_cpu;
+	rk_fiq_sdei.fiq_en = 1;
+	return 0;
+cpu_sw_err:
+	for (i = 0; i < cpu; i++)
+		sdei_event_unregister(rk_fiq_sdei.cpu_sw_event_id + i);
+err:
+	unregister_pm_notifier(&fiq_dbg_sdei_pm_nb);
+	sdei_event_unregister(rk_fiq_sdei.event_id);
+
+	if (is_dyn_event)
+		sdei_interrupt_release(rk_fiq_sdei.event_id);
+
+	return ret;
+}
+
+#else
+static inline int fiq_debugger_sdei_enable(struct rk_fiq_debugger *t)
+{
+	return -EINVAL;
+}
+#endif
+
+static void rk_fiq_debugger_switch_cpu(struct platform_device *pdev,
+				       unsigned int cpu)
+{
+	sip_fiq_debugger_switch_cpu(cpu);
+}
+
+static void rk_fiq_debugger_enable_debug(struct platform_device *pdev, bool val)
+{
+	sip_fiq_debugger_enable_debug(val);
+}
+
+static void fiq_debugger_uart_irq_tf(struct pt_regs *_pt_regs, unsigned long cpu)
+{
+	fiq_debugger_fiq(_pt_regs, cpu);
+}
+
+static int rk_fiq_debugger_uart_dev_resume(struct platform_device *pdev)
+{
+	struct rk_fiq_debugger *t;
+
+	t = container_of(dev_get_platdata(&pdev->dev), typeof(*t), pdata);
+	sip_fiq_debugger_uart_irq_tf_init(serial_hwirq,
+					  fiq_debugger_uart_irq_tf);
+	return 0;
+}
+
+/*
+ * We don't need to migrate fiq before cpuidle, because EL3 can promise to
+ * resume all fiq configure. We don't want fiq to break kernel cpu_resume(),
+ * so that fiq would be disabled in EL3 on purpose when cpu resume. We enable
+ * it here since everything is okay.
+ */
+static int fiq_debugger_cpuidle_resume_fiq(struct notifier_block *nb,
+					   unsigned long action, void *hcpu)
+{
+	switch (action) {
+	case CPU_PM_EXIT:
+		if ((sip_fiq_debugger_is_enabled()) &&
+		    (sip_fiq_debugger_get_target_cpu() == smp_processor_id()))
+			sip_fiq_debugger_enable_fiq(true, smp_processor_id());
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+/*
+ * We must migrate fiq before cpu offline, because EL3 doesn't promise to
+ * resume all fiq configure at this sisutation. Here, we migrate fiq to any
+ * online cpu.
+ */
+static int fiq_debugger_cpu_offine_migrate_fiq(unsigned int cpu)
+{
+	unsigned int target_cpu;
+
+	if ((sip_fiq_debugger_is_enabled()) &&
+	    (sip_fiq_debugger_get_target_cpu() == cpu)) {
+		target_cpu = cpumask_any_but(cpu_online_mask, cpu);
+		if (target_cpu >= nr_cpu_ids) {
+			pr_err("%s: migrate fiq fail!\n", __func__);
+			return -EBUSY;
+		}
+
+		sip_fiq_debugger_switch_cpu(target_cpu);
+	}
+
+	return 0;
+}
+
+static struct notifier_block fiq_debugger_pm_notifier = {
+	.notifier_call = fiq_debugger_cpuidle_resume_fiq,
+	.priority = 100,
+};
+
+static int rk_fiq_debugger_register_cpu_pm_notify(void)
+{
+	int err;
+
+	err = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
+					"soc/rk_fiq_debugger",
+					NULL,
+					fiq_debugger_cpu_offine_migrate_fiq);
+	if (err < 0) {
+		pr_err("fiq debugger register cpu notifier failed!\n");
+		return err;
+	}
+
+	err = cpu_pm_register_notifier(&fiq_debugger_pm_notifier);
+	if (err) {
+		pr_err("fiq debugger register pm notifier failed!\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static int fiq_debugger_bind_sip_smc(struct rk_fiq_debugger *t,
+				     phys_addr_t phy_base,
+				     int hwirq,
+				     int signal_irq,
+				     unsigned int baudrate)
+{
+	int err;
+
+	err = sip_fiq_debugger_request_share_memory();
+	if (err) {
+		pr_err("fiq debugger request share memory failed: %d\n", err);
+		goto exit;
+	}
+
+	err = rk_fiq_debugger_register_cpu_pm_notify();
+	if (err) {
+		pr_err("fiq debugger register cpu pm notify failed: %d\n", err);
+		goto exit;
+	}
+
+	err = sip_fiq_debugger_uart_irq_tf_init(hwirq,
+				fiq_debugger_uart_irq_tf);
+	if (err) {
+		pr_err("fiq debugger bind fiq to trustzone failed: %d\n", err);
+		goto exit;
+	}
+
+	t->pdata.uart_dev_resume = rk_fiq_debugger_uart_dev_resume;
+	t->pdata.switch_cpu = rk_fiq_debugger_switch_cpu;
+	t->pdata.enable_debug = rk_fiq_debugger_enable_debug;
+	sip_fiq_debugger_set_print_port(phy_base, baudrate);
+
+	pr_info("fiq debugger fiq mode enabled\n");
+
+	return 0;
+
+exit:
+	t->pdata.switch_cpu = NULL;
+	t->pdata.enable_debug = NULL;
+
+	return err;
+}
+#endif
+
+static void rk_serial_debug_init(void __iomem *base, phys_addr_t phy_base,
+				 int irq, int signal_irq,
+				 int wakeup_irq, unsigned int baudrate)
+{
+	struct rk_fiq_debugger *t = NULL;
+	struct platform_device *pdev = NULL;
+	struct resource *res = NULL;
+	int res_count = 0;
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+	int ret = 0;
+#endif
+
+	if (!base) {
+		pr_err("Invalid fiq debugger uart base\n");
+		return;
+	}
+
+	t = kzalloc(sizeof(struct rk_fiq_debugger), GFP_KERNEL);
+	if (!t) {
+		pr_err("Failed to allocate for fiq debugger\n");
+		return;
+	}
+
+	t->irq = irq;
+	t->baudrate = baudrate;
+	t->pdata.uart_init = debug_port_init;
+	t->pdata.uart_getc = debug_getc;
+	t->pdata.uart_putc = debug_putc;
+#ifndef CONFIG_RK_CONSOLE_THREAD
+	t->pdata.uart_flush = debug_flush;
+#endif
+	t->pdata.fiq_enable = fiq_enable;
+	t->pdata.force_irq = NULL;
+	t->debug_port_base = base;
+
+	res = kzalloc(sizeof(struct resource) * 3, GFP_KERNEL);
+	if (!res) {
+		pr_err("Failed to alloc fiq debugger resources\n");
+		goto out2;
+	}
+
+	pdev = kzalloc(sizeof(struct platform_device), GFP_KERNEL);
+	if (!pdev) {
+		pr_err("Failed to alloc fiq debugger platform device\n");
+		goto out3;
+	}
+
+	/* clear busy interrupt, make sure all interrupts are disabled */
+	rk_fiq_read(t, UART_USR);
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+	if ((signal_irq > 0) && (serial_hwirq > 0)) {
+		ret = fiq_debugger_sdei_enable(t);
+		if (ret)
+			ret = fiq_debugger_bind_sip_smc(t, phy_base,
+							serial_hwirq,
+							signal_irq, baudrate);
+		if (ret)
+			tf_fiq_sup = false;
+		else
+			tf_fiq_sup = true;
+	}
+#endif
+
+	if (irq > 0) {
+		res[0].flags = IORESOURCE_IRQ;
+		res[0].start = irq;
+		res[0].end = irq;
+#if defined(CONFIG_FIQ_GLUE)
+		if (signal_irq > 0)
+			res[0].name = "fiq";
+		else
+			res[0].name = "uart_irq";
+#elif defined(CONFIG_FIQ_DEBUGGER_TRUST_ZONE)
+		if (tf_fiq_sup && (signal_irq > 0))
+			res[0].name = "fiq";
+		else
+			res[0].name = "uart_irq";
+#else
+		res[0].name = "uart_irq";
+#endif
+		res_count++;
+	}
+
+	if (signal_irq > 0) {
+		res[1].flags = IORESOURCE_IRQ;
+		res[1].start = signal_irq;
+		res[1].end = signal_irq;
+		res[1].name = "signal";
+		res_count++;
+	}
+
+	if (wakeup_irq > 0) {
+		res[2].flags = IORESOURCE_IRQ;
+		res[2].start = wakeup_irq;
+		res[2].end = wakeup_irq;
+		res[2].name = "wakeup";
+		res_count++;
+	}
+
+#ifdef CONFIG_RK_CONSOLE_THREAD
+	t->console_task = kthread_run(console_thread, pdev, "kconsole");
+	if (!IS_ERR(t->console_task)) {
+		t->pdata.console_write = console_write;
+		t->pdata.tty_write = tty_write;
+		t->pdata.write_room = write_room;
+	}
+#endif
+
+	pdev->name = "fiq_debugger";
+	pdev->id = rk_fiq_debugger_id++;
+	pdev->dev.platform_data = &t->pdata;
+	pdev->resource = res;
+	pdev->num_resources = res_count;
+	if (platform_device_register(pdev)) {
+		pr_err("Failed to register fiq debugger\n");
+		goto out4;
+	}
+	return;
+
+out4:
+	kfree(pdev);
+out3:
+	kfree(res);
+out2:
+	kfree(t);
+}
+
+static void rk_serial_debug_init_dummy(void)
+{
+	struct rk_fiq_debugger *t = NULL;
+	struct platform_device *pdev = NULL;
+
+	t = kzalloc(sizeof(*t), GFP_KERNEL);
+	if (!t) {
+		pr_err("Failed to allocate for fiq debugger\n");
+		return;
+	}
+
+	t->pdata.uart_getc = debug_getc_dummy;
+	t->pdata.uart_putc = debug_putc_dummy;
+
+	pdev = kzalloc(sizeof(*pdev), GFP_KERNEL);
+	if (!pdev) {
+		pr_err("Failed to alloc fiq debugger platform device\n");
+		goto out2;
+	}
+
+	pdev->name = "fiq_debugger";
+	pdev->id = rk_fiq_debugger_id++;
+	pdev->dev.platform_data = &t->pdata;
+	if (platform_device_register(pdev)) {
+		pr_err("Failed to register fiq debugger\n");
+		goto out3;
+	}
+	return;
+
+out3:
+	kfree(pdev);
+out2:
+	kfree(t);
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id rk_fiqdbg_of_match[] = {
+	{ .compatible = "rockchip,fiq-debugger", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rk_fiqdbg_of_match);
+#endif
+
+static int __init rk_fiqdbg_probe(struct platform_device *pdev)
+{
+	void __iomem *base;
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int id, ok = 0;
+	int irq, signal_irq = -1, wake_irq = -1;
+	unsigned int baudrate = 0, irq_mode = 0;
+	phys_addr_t phy_base = 0;
+	int serial_id;
+	struct clk *clk;
+	struct clk *pclk;
+	struct of_phandle_args oirq;
+	struct resource res;
+
+	if (!of_device_is_available(np)) {
+		pr_err("fiq-debugger is disabled in device tree\n");
+		return -ENODEV;
+	}
+
+	if (of_property_read_u32(np, "rockchip,serial-id", &serial_id))
+		return -EINVAL;
+
+	if (serial_id == -1) {
+		rk_serial_debug_init_dummy();
+		return 0;
+	}
+
+	if (of_property_read_u32(np, "rockchip,irq-mode-enable", &irq_mode))
+		irq_mode = -1;
+
+	signal_irq = irq_of_parse_and_map(np, 0);
+	if (!signal_irq)
+		return -EINVAL;
+
+	if (of_property_read_u32(np, "rockchip,wake-irq", &wake_irq))
+		wake_irq = -1;
+
+	if (of_property_read_u32(np, "rockchip,baudrate", &baudrate))
+		baudrate = -1;
+
+	np = NULL;
+
+	do {
+		np = of_find_node_by_name(np, "serial");
+		if (np) {
+			id = of_alias_get_id(np, "serial");
+			if (id == serial_id) {
+				ok = 1;
+				break;
+			}
+		}
+	} while(np);
+
+	if (!ok)
+		return -EINVAL;
+
+	if (of_device_is_available(np)) {
+		pr_err("uart%d is enabled, please disable it\n", serial_id);
+		return -EINVAL;
+	}
+
+	/* parse serial hw irq */
+	if (irq_mode != 1 && !of_irq_parse_one(np, 0, &oirq))
+		serial_hwirq = oirq.args[1] + 32;
+
+	/* parse serial phy base address */
+	if (!of_address_to_resource(np, 0, &res))
+		phy_base = res.start;
+
+	pclk = of_clk_get_by_name(np, "apb_pclk");
+	clk = of_clk_get_by_name(np, "baudclk");
+	if (unlikely(IS_ERR(clk)) || unlikely(IS_ERR(pclk))) {
+		pr_err("fiq-debugger get clock fail\n");
+		return -EINVAL;
+	}
+#ifdef CONFIG_RK_CONSOLE_THREAD
+	if (kfifo_alloc(&fifo, FIFO_SIZE, GFP_KERNEL)) {
+		pr_err("fiq-debugger alloc fifo fail\n");
+		return -ENOMEM;
+	}
+
+	if (kfifo_alloc(&tty_fifo, TTY_FIFO_SIZE, GFP_KERNEL)) {
+		pr_err("fiq-debugger alloc tty_fifo fail\n");
+		return -ENOMEM;
+	}
+#endif
+	clk_prepare_enable(clk);
+	clk_prepare_enable(pclk);
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (!irq)
+		return -EINVAL;
+
+	base = of_iomap(np, 0);
+	if (base)
+		rk_serial_debug_init(base, phy_base,
+				     irq, signal_irq, wake_irq, baudrate);
+	return 0;
+}
+
+static struct platform_driver rk_fiqdbg_driver = {
+	.driver = {
+		.name   = "rk-fiq-debugger",
+		.of_match_table = of_match_ptr(rk_fiqdbg_of_match),
+	},
+};
+
+static int __init rk_fiqdbg_init(void)
+{
+	return platform_driver_probe(&rk_fiqdbg_driver,
+				     rk_fiqdbg_probe);
+}
+
+#if defined(CONFIG_FIQ_DEBUGGER_TRUST_ZONE) && defined(CONFIG_ARM_SDE_INTERFACE)
+fs_initcall(rk_fiqdbg_init);
+#else
+subsys_initcall(rk_fiqdbg_init); /* after of_platform_default_populate_init */
+#endif
+
+static void __exit rk_fiqdbg_exit(void)
+{
+	platform_driver_unregister(&rk_fiqdbg_driver);
+}
+module_exit(rk_fiqdbg_exit);
+
+MODULE_AUTHOR("Huibin Hong <huibin.hong@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip FIQ Debugger");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rk-fiq-debugger");

--- /dev/null
+++ b/drivers/soc/rockchip/fiq_debugger/rk_fiq_debugger.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __PLAT_RK_FIQ_DEBUGGER_H
+#define __PLAT_RK_FIQ_DEBUGGER_H
+
+#ifdef CONFIG_FIQ_DEBUGGER_TRUST_ZONE
+void fiq_debugger_fiq(void *regs, u32 cpu);
+
+#ifdef CONFIG_ARM_SDE_INTERFACE
+int sdei_fiq_debugger_is_enabled(void);
+int fiq_sdei_event_enable(u32 event_num);
+int fiq_sdei_event_routing_set(u32 event_num, unsigned long flags,
+			       unsigned long affinity);
+int fiq_sdei_event_disable(u32 event_num);
+#else
+static inline int sdei_fiq_debugger_is_enabled(void)
+{
+	return 0;
+}
+#endif
+#endif
+
+#endif

--- a/drivers/soc/rockchip/Kconfig
+++ b/drivers/soc/rockchip/Kconfig
@@ -1,5 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-only
 if ARCH_ROCKCHIP || COMPILE_TEST
+
+source "drivers/soc/rockchip/fiq_debugger/Kconfig"
 
 #
 # Rockchip Soc drivers
--- a/drivers/soc/rockchip/Makefile
+++ b/drivers/soc/rockchip/Makefile
@@ -4,3 +4,4 @@
 obj-$(CONFIG_ROCKCHIP_GRF) += grf.o
 obj-$(CONFIG_ROCKCHIP_IODOMAIN) += io-domain.o
 obj-$(CONFIG_ROCKCHIP_DTPM) += dtpm.o
+obj-y += fiq_debugger/
